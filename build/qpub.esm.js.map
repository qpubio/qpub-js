{"version":3,"file":"qpub.esm.js","sources":["../node_modules/tslib/tslib.es6.js","../src/core/bootstrap/container.ts","../src/types/protocol/actions.ts","../src/types/config/options.ts","../src/core/managers/option-manager.ts","../src/core/transport/http-client.ts","../src/core/shared/logger.ts","../src/core/shared/event-emitter.ts","../src/core/shared/crypto.ts","../src/core/shared/jwt.ts","../src/core/shared/api-key.ts","../src/types/events/constants.ts","../src/core/managers/auth-manager.ts","../src/core/connections/websocket-client.ts","../src/core/channels/channel.ts","../src/core/channels/socket-channel.ts","../src/core/channels/rest-channel.ts","../src/core/managers/channel-manager.ts","../src/core/connections/connection.ts","../src/core/bootstrap/registry.ts","../src/core/shared/uuid.ts","../src/core/rest.ts","../src/core/socket.ts","../src/testing/index.ts","../src/qpub.ts"],"sourcesContent":["/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\r\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\r\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\r\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\r\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\r\n    var _, done = false;\r\n    for (var i = decorators.length - 1; i >= 0; i--) {\r\n        var context = {};\r\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\r\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\r\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\r\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\r\n        if (kind === \"accessor\") {\r\n            if (result === void 0) continue;\r\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\r\n            if (_ = accept(result.get)) descriptor.get = _;\r\n            if (_ = accept(result.set)) descriptor.set = _;\r\n            if (_ = accept(result.init)) initializers.unshift(_);\r\n        }\r\n        else if (_ = accept(result)) {\r\n            if (kind === \"field\") initializers.unshift(_);\r\n            else descriptor[key] = _;\r\n        }\r\n    }\r\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\r\n    done = true;\r\n};\r\n\r\nexport function __runInitializers(thisArg, initializers, value) {\r\n    var useValue = arguments.length > 2;\r\n    for (var i = 0; i < initializers.length; i++) {\r\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\r\n    }\r\n    return useValue ? value : void 0;\r\n};\r\n\r\nexport function __propKey(x) {\r\n    return typeof x === \"symbol\" ? x : \"\".concat(x);\r\n};\r\n\r\nexport function __setFunctionName(f, name, prefix) {\r\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\r\n    return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\r\n};\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\r\n    return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\r\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nvar ownKeys = function(o) {\r\n    ownKeys = Object.getOwnPropertyNames || function (o) {\r\n        var ar = [];\r\n        for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\r\n        return ar;\r\n    };\r\n    return ownKeys(o);\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n\r\nexport function __addDisposableResource(env, value, async) {\r\n    if (value !== null && value !== void 0) {\r\n        if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\r\n        var dispose, inner;\r\n        if (async) {\r\n            if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\r\n            dispose = value[Symbol.asyncDispose];\r\n        }\r\n        if (dispose === void 0) {\r\n            if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\r\n            dispose = value[Symbol.dispose];\r\n            if (async) inner = dispose;\r\n        }\r\n        if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\r\n        if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };\r\n        env.stack.push({ value: value, dispose: dispose, async: async });\r\n    }\r\n    else if (async) {\r\n        env.stack.push({ async: true });\r\n    }\r\n    return value;\r\n\r\n}\r\n\r\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\r\n\r\nexport function __disposeResources(env) {\r\n    function fail(e) {\r\n        env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\r\n        env.hasError = true;\r\n    }\r\n    var r, s = 0;\r\n    function next() {\r\n        while (r = env.stack.pop()) {\r\n            try {\r\n                if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\r\n                if (r.dispose) {\r\n                    var result = r.dispose.call(r.value);\r\n                    if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\r\n                }\r\n                else s |= 1;\r\n            }\r\n            catch (e) {\r\n                fail(e);\r\n            }\r\n        }\r\n        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\r\n        if (env.hasError) throw env.error;\r\n    }\r\n    return next();\r\n}\r\n\r\nexport function __rewriteRelativeImportExtension(path, preserveJsx) {\r\n    if (typeof path === \"string\" && /^\\.\\.?\\//.test(path)) {\r\n        return path.replace(/\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+?)?)\\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {\r\n            return tsx ? preserveJsx ? \".jsx\" : \".js\" : d && (!ext || !cm) ? m : (d + ext + \".\" + cm.toLowerCase() + \"js\");\r\n        });\r\n    }\r\n    return path;\r\n}\r\n\r\nexport default {\r\n    __extends: __extends,\r\n    __assign: __assign,\r\n    __rest: __rest,\r\n    __decorate: __decorate,\r\n    __param: __param,\r\n    __esDecorate: __esDecorate,\r\n    __runInitializers: __runInitializers,\r\n    __propKey: __propKey,\r\n    __setFunctionName: __setFunctionName,\r\n    __metadata: __metadata,\r\n    __awaiter: __awaiter,\r\n    __generator: __generator,\r\n    __createBinding: __createBinding,\r\n    __exportStar: __exportStar,\r\n    __values: __values,\r\n    __read: __read,\r\n    __spread: __spread,\r\n    __spreadArrays: __spreadArrays,\r\n    __spreadArray: __spreadArray,\r\n    __await: __await,\r\n    __asyncGenerator: __asyncGenerator,\r\n    __asyncDelegator: __asyncDelegator,\r\n    __asyncValues: __asyncValues,\r\n    __makeTemplateObject: __makeTemplateObject,\r\n    __importStar: __importStar,\r\n    __importDefault: __importDefault,\r\n    __classPrivateFieldGet: __classPrivateFieldGet,\r\n    __classPrivateFieldSet: __classPrivateFieldSet,\r\n    __classPrivateFieldIn: __classPrivateFieldIn,\r\n    __addDisposableResource: __addDisposableResource,\r\n    __disposeResources: __disposeResources,\r\n    __rewriteRelativeImportExtension: __rewriteRelativeImportExtension,\r\n};\r\n","/**\n * Service lifetime options for dependency injection\n */\nexport type ServiceLifetime = \"singleton\" | \"transient\";\n\n/**\n * Definition of a service in the container\n */\ninterface ServiceDefinition<T = any> {\n    /** Factory function to create the service instance */\n    factory: (container: ServiceContainer) => T;\n    /** Service lifetime - singleton (cached) or transient (new instance each time) */\n    lifetime: ServiceLifetime;\n    /** List of service keys this service depends on (for validation) */\n    dependencies?: string[];\n}\n\n/**\n * Options for service registration\n */\nexport interface ServiceRegistrationOptions {\n    /** Service lifetime - defaults to 'singleton' */\n    lifetime?: ServiceLifetime;\n    /** List of service keys this service depends on */\n    dependencies?: string[];\n}\n\n/**\n * Type-safe dependency injection container\n *\n * Manages service registration, resolution, and lifecycle for a specific instance.\n * Each Socket/Rest instance gets its own container for complete isolation.\n */\nexport class ServiceContainer {\n    private readonly definitions = new Map<string, ServiceDefinition>();\n    private readonly instances = new Map<string, any>();\n    private readonly instanceId: string;\n    private readonly resolutionStack: string[] = [];\n\n    constructor(instanceId: string) {\n        this.instanceId = instanceId;\n    }\n\n    /**\n     * Register a service in the container\n     *\n     * @param key - Unique identifier for the service\n     * @param factory - Function that creates the service instance\n     * @param options - Registration options (lifetime, dependencies)\n     */\n    register<T>(\n        key: string,\n        factory: (container: ServiceContainer) => T,\n        options: ServiceRegistrationOptions = {}\n    ): void {\n        if (this.definitions.has(key)) {\n            throw new Error(\n                `Service '${key}' is already registered in container '${this.instanceId}'`\n            );\n        }\n\n        this.definitions.set(key, {\n            factory,\n            lifetime: options.lifetime ?? \"singleton\",\n            dependencies: options.dependencies ?? [],\n        });\n    }\n\n    /**\n     * Resolve a service from the container\n     *\n     * @param key - Service identifier to resolve\n     * @returns The service instance\n     */\n    resolve<T>(key: string): T {\n        // Check for circular dependencies\n        if (this.resolutionStack.includes(key)) {\n            const cycle = [...this.resolutionStack, key].join(\" -> \");\n            throw new Error(\n                `Circular dependency detected in container '${this.instanceId}': ${cycle}`\n            );\n        }\n\n        // Return existing singleton instance if available\n        if (this.instances.has(key)) {\n            return this.instances.get(key);\n        }\n\n        // Get service definition\n        const definition = this.definitions.get(key);\n        if (!definition) {\n            throw new Error(\n                `Service '${key}' not found in container '${this.instanceId}'. ` +\n                    `Available services: ${Array.from(\n                        this.definitions.keys()\n                    ).join(\", \")}`\n            );\n        }\n\n        // Add to resolution stack for circular dependency detection\n        this.resolutionStack.push(key);\n\n        try {\n            // Create the service instance\n            const instance = definition.factory(this);\n\n            // Cache singleton instances\n            if (definition.lifetime === \"singleton\") {\n                this.instances.set(key, instance);\n            }\n\n            return instance;\n        } catch (error) {\n            throw new Error(\n                `Failed to resolve service '${key}' in container '${\n                    this.instanceId\n                }': ${error instanceof Error ? error.message : String(error)}`\n            );\n        } finally {\n            // Remove from resolution stack\n            this.resolutionStack.pop();\n        }\n    }\n\n    /**\n     * Check if a service is registered\n     *\n     * @param key - Service identifier to check\n     * @returns True if the service is registered\n     */\n    isRegistered(key: string): boolean {\n        return this.definitions.has(key);\n    }\n\n    /**\n     * Check if a service has been instantiated (for singletons)\n     *\n     * @param key - Service identifier to check\n     * @returns True if the service instance exists\n     */\n    isInstantiated(key: string): boolean {\n        return this.instances.has(key);\n    }\n\n    /**\n     * Get list of all registered service keys\n     */\n    getRegisteredServices(): string[] {\n        return Array.from(this.definitions.keys());\n    }\n\n    /**\n     * Get the instance ID for this container\n     */\n    getInstanceId(): string {\n        return this.instanceId;\n    }\n\n    /**\n     * Validate all registered services and their dependencies\n     *\n     * @throws Error if any dependencies are missing or circular\n     */\n    validate(): void {\n        const allServices = new Set(this.definitions.keys());\n\n        // Check if all dependencies are registered\n        Array.from(this.definitions.entries()).forEach(\n            ([serviceKey, definition]) => {\n                for (const dependency of definition.dependencies || []) {\n                    if (!allServices.has(dependency)) {\n                        throw new Error(\n                            `Service '${serviceKey}' depends on '${dependency}' which is not registered ` +\n                                `in container '${this.instanceId}'`\n                        );\n                    }\n                }\n            }\n        );\n\n        // Validate no circular dependencies using dependency graph analysis\n        // This avoids creating actual instances during validation\n        this.validateCircularDependencies(allServices);\n    }\n\n    /**\n     * Validate circular dependencies using topological sort without instantiating services\n     */\n    private validateCircularDependencies(allServices: Set<string>): void {\n        const visited = new Set<string>();\n        const visiting = new Set<string>();\n\n        const visit = (serviceKey: string, path: string[] = []): void => {\n            if (visiting.has(serviceKey)) {\n                const cycle = [...path, serviceKey].join(\" -> \");\n                throw new Error(\n                    `Circular dependency detected in container '${this.instanceId}': ${cycle}`\n                );\n            }\n\n            if (visited.has(serviceKey)) {\n                return;\n            }\n\n            visiting.add(serviceKey);\n            const definition = this.definitions.get(serviceKey);\n            \n            if (definition && definition.dependencies) {\n                for (const dependency of definition.dependencies) {\n                    visit(dependency, [...path, serviceKey]);\n                }\n            }\n\n            visiting.delete(serviceKey);\n            visited.add(serviceKey);\n        };\n\n        // Visit all services to detect circular dependencies\n        Array.from(allServices).forEach((serviceKey) => {\n            if (!visited.has(serviceKey)) {\n                visit(serviceKey);\n            }\n        });\n    }\n\n    /**\n     * Clear all cached singleton instances\n     * Useful for testing or cleanup scenarios\n     */\n    clearInstances(): void {\n        this.instances.clear();\n    }\n\n    /**\n     * Reset the entire container (clear definitions and instances)\n     */\n    reset(): void {\n        this.definitions.clear();\n        this.instances.clear();\n    }\n}\n","/**\n * Protocol Actions\n * \n * Action types and helpers that match the backend WebSocket protocol.\n * These define the communication contract between client and server.\n */\n\n// Action types enum matching backend protocol\nexport enum ActionType {\n    // Connection actions\n    CONNECT = 0,\n    CONNECTED = 1,\n    DISCONNECT = 2,\n    DISCONNECTED = 3,\n\n    // Channel actions\n    SUBSCRIBE = 4,\n    SUBSCRIBED = 5,\n    UNSUBSCRIBE = 6,\n    UNSUBSCRIBED = 7,\n\n    // Data Message actions\n    PUBLISH = 8,\n    PUBLISHED = 9,\n    MESSAGE = 10,\n\n    // Error actions\n    ERROR = 11,\n\n    // Heartbeat actions (for browser compatibility)\n    PING = 12,\n    PONG = 13\n}\n\n// Action type string mapping\nexport const ActionStrings: Record<ActionType, string> = {\n    [ActionType.CONNECT]: \"connect\",\n    [ActionType.CONNECTED]: \"connected\",\n    [ActionType.DISCONNECT]: \"disconnect\",\n    [ActionType.DISCONNECTED]: \"disconnected\",\n    [ActionType.SUBSCRIBE]: \"subscribe\",\n    [ActionType.SUBSCRIBED]: \"subscribed\",\n    [ActionType.UNSUBSCRIBE]: \"unsubscribe\",\n    [ActionType.UNSUBSCRIBED]: \"unsubscribed\",\n    [ActionType.PUBLISH]: \"publish\",\n    [ActionType.PUBLISHED]: \"published\",\n    [ActionType.MESSAGE]: \"message\",\n    [ActionType.ERROR]: \"error\",\n    [ActionType.PING]: \"ping\",\n    [ActionType.PONG]: \"pong\"\n};\n\n// Helper to convert ActionType to string\nexport function actionToString(action: ActionType): string {\n    return ActionStrings[action];\n}\n\n// Grouping of action types for type safety\nexport const ConnectionActions = [\n    ActionType.CONNECT,\n    ActionType.CONNECTED,\n    ActionType.DISCONNECT,\n    ActionType.DISCONNECTED\n] as const;\n\nexport type ConnectionAction = typeof ConnectionActions[number];\n\nexport const ChannelActions = [\n    ActionType.SUBSCRIBE,\n    ActionType.UNSUBSCRIBE,\n    ActionType.PUBLISH\n] as const;\n\nexport type ChannelAction = typeof ChannelActions[number];\n\nexport const ChannelResponseActions = [\n    ActionType.SUBSCRIBED,\n    ActionType.UNSUBSCRIBED,\n    ActionType.PUBLISHED,\n    ActionType.MESSAGE\n] as const;\n\nexport type ChannelResponseAction = typeof ChannelResponseActions[number];\n\nexport const ErrorActions = [\n    ActionType.ERROR\n] as const;\n\nexport type ErrorAction = typeof ErrorActions[number];\n\n// Combined types for message interfaces\nexport type OutgoingAction = ActionType.CONNECT | ActionType.DISCONNECT | ActionType.SUBSCRIBE | ActionType.UNSUBSCRIBE | ActionType.PUBLISH | ActionType.PING;\nexport type IncomingAction = ActionType.CONNECTED | ActionType.DISCONNECTED | ActionType.SUBSCRIBED | ActionType.UNSUBSCRIBED | ActionType.PUBLISHED | ActionType.MESSAGE | ActionType.ERROR | ActionType.PING | ActionType.PONG;\n\n","/**\n * Configuration Options\n * \n * SDK configuration options and defaults.\n */\n\nimport { TokenRequest } from \"./auth\";\n\nexport interface AuthOptions {\n    headers?: Record<string, string>;\n    body?: Record<string, any>;\n}\n\nexport interface Option {\n    apiKey?: string;\n    authUrl?: string;\n    authOptions?: AuthOptions;\n    tokenRequest?: TokenRequest;\n\n    alias?: string; // Optional client alias for basic auth (untrusted client)\n\n    httpHost?: string;\n    httpPort?: number | null;\n\n    wsHost?: string;\n    wsPort?: number | null;\n\n    isSecure?: boolean;\n\n    autoConnect?: boolean;\n    autoReconnect?: boolean;\n    autoResubscribe?: boolean;\n    autoAuthenticate?: boolean;\n\n    connectTimeoutMs?: number;\n\n    maxReconnectAttempts?: number;\n    initialReconnectDelayMs?: number;\n    maxReconnectDelayMs?: number;\n    reconnectBackoffMultiplier?: number;\n\n    resubscribeIntervalMs?: number; // Not used yet\n    authenticateRetries?: number;\n    authenticateRetryIntervalMs?: number;\n\n    pingTimeoutMs?: number;\n\n    debug?: boolean;\n    logLevel?: \"error\" | \"warn\" | \"info\" | \"debug\" | \"trace\";\n    logger?: (level: string, message: string, ...args: any[]) => void;\n}\n\nexport const DEFAULT_OPTIONS: Option = {\n    httpHost: \"rest.qpub.io\",\n    httpPort: null,\n\n    wsHost: \"socket.qpub.io\",\n    wsPort: null,\n\n    isSecure: true,\n\n    autoConnect: true,\n    autoReconnect: true,\n    autoResubscribe: true,\n    autoAuthenticate: true,\n\n    connectTimeoutMs: 10000,\n\n    maxReconnectAttempts: 10,\n    initialReconnectDelayMs: 1000,\n    maxReconnectDelayMs: 30000,\n    reconnectBackoffMultiplier: 1.5,\n\n    resubscribeIntervalMs: 1000,\n    authenticateRetries: 3,\n    authenticateRetryIntervalMs: 1000,\n\n    pingTimeoutMs: 10000,\n\n    debug: false,\n    logLevel: \"error\",\n};\n\n","import { DEFAULT_OPTIONS, Option } from \"../../types/config/options\";\nimport { IOptionManager } from \"../../types/services/managers\";\n\nexport class OptionManager implements IOptionManager {\n    private options: Option;\n\n    constructor(options: Partial<Option> = {}) {\n        this.options = { ...DEFAULT_OPTIONS, ...options };\n    }\n\n    public getOption(): Option;\n    public getOption<K extends keyof Option>(optionName: K): Option[K];\n    public getOption<K extends keyof Option>(optionName?: K) {\n        return optionName ? this.options[optionName] : this.options;\n    }\n\n    public setOption(newOption: Partial<Option>): void {\n        this.options = { ...this.options, ...newOption };\n    }\n\n    public reset(): void {\n        this.options = { ...DEFAULT_OPTIONS };\n    }\n}\n","import { IHttpClient } from \"../../types/services/clients\";\n\nexport class HttpClient implements IHttpClient {\n    private defaultHeaders: HeadersInit;\n    private fetchImpl: typeof fetch;\n\n    constructor(defaultHeaders: HeadersInit = {}, customFetch?: typeof fetch) {\n        this.defaultHeaders = {\n            \"Content-Type\": \"application/json\",\n            ...defaultHeaders,\n        };\n        this.fetchImpl = customFetch || this.getDefaultFetch();\n    }\n\n    private getDefaultFetch(): typeof fetch {\n        if (typeof fetch === \"function\") {\n            // Bind fetch to the global context to avoid \"Illegal invocation\" errors\n            return fetch.bind(globalThis);\n        }\n\n        // Node.js environment without global fetch\n        return this.createNodeFetch();\n    }\n\n    private createNodeFetch(): typeof fetch {\n        // Only import Node.js modules if we're in Node.js environment\n        const http = require(\"http\");\n        const https = require(\"https\");\n        const { URL } = require(\"url\");\n\n        return async (\n            input: string | URL | RequestInfo,\n            init?: RequestInit\n        ) => {\n            return new Promise((resolve, reject) => {\n                const parsed =\n                    typeof input === \"string\"\n                        ? new URL(input)\n                        : input instanceof URL\n                        ? input\n                        : new URL(input.toString());\n                const protocol = parsed.protocol === \"https:\" ? https : http;\n                const options = {\n                    method: init?.method || \"GET\",\n                    headers: init?.headers || {},\n                    hostname: parsed.hostname,\n                    path: parsed.pathname + parsed.search,\n                    port:\n                        parsed.port ||\n                        (parsed.protocol === \"https:\" ? 443 : 80),\n                };\n\n                const req = protocol.request(options, (res: any) => {\n                    const chunks: Buffer[] = [];\n                    res.on(\"data\", (chunk: Buffer) => chunks.push(chunk));\n                    res.on(\"end\", () => {\n                        const body = Buffer.concat(chunks).toString();\n\n                        const response = {\n                            ok: res.statusCode >= 200 && res.statusCode < 300,\n                            status: res.statusCode,\n                            statusText: res.statusMessage,\n                            headers: res.headers,\n                            json: () => Promise.resolve(JSON.parse(body)),\n                            text: () => Promise.resolve(body),\n                        };\n\n                        resolve(response as Response);\n                    });\n                });\n\n                req.on(\"error\", reject);\n\n                if (init?.body) {\n                    req.write(init.body);\n                }\n                req.end();\n            });\n        };\n    }\n\n    private async request<T>(url: string, options: RequestInit): Promise<T> {\n        const response = await this.fetchImpl(url, {\n            ...options,\n            headers: {\n                ...this.defaultHeaders,\n                ...options.headers,\n            },\n        });\n\n        if (!response.ok) {\n            throw new Error(\n                `HTTP Error: ${response.status} ${response.statusText}`\n            );\n        }\n\n        return response.json();\n    }\n\n    async get<T>(url: string, headers: HeadersInit = {}): Promise<T> {\n        return this.request<T>(url, {\n            method: \"GET\",\n            headers,\n        });\n    }\n\n    async post<T>(\n        url: string,\n        data: unknown,\n        headers: HeadersInit = {}\n    ): Promise<T> {\n        return this.request<T>(url, {\n            method: \"POST\",\n            headers,\n            body: JSON.stringify(data),\n        });\n    }\n\n    async put<T>(\n        url: string,\n        data: unknown,\n        headers: HeadersInit = {}\n    ): Promise<T> {\n        return this.request<T>(url, {\n            method: \"PUT\",\n            headers,\n            body: JSON.stringify(data),\n        });\n    }\n\n    async delete<T>(url: string, headers: HeadersInit = {}): Promise<T> {\n        return this.request<T>(url, {\n            method: \"DELETE\",\n            headers,\n        });\n    }\n\n    async patch<T>(\n        url: string,\n        data: unknown,\n        headers: HeadersInit = {}\n    ): Promise<T> {\n        return this.request<T>(url, {\n            method: \"PATCH\",\n            headers,\n            body: JSON.stringify(data),\n        });\n    }\n}\n","import { IOptionManager } from \"../../types/services/managers\";\nimport { ILogger } from \"../../types/services/clients\";\n\n/**\n * High-performance logger with early-exit optimization.\n *\n * Performance characteristics:\n * - When debug is disabled: ~1-2μs overhead per call (just checks debug flag)\n * - When debug is enabled: ~10-50μs for formatting + async console output\n * - Console operations are non-blocking (async in browsers/Node.js)\n *\n * Note: String interpolation in log calls (e.g., `logger.debug(\\`text \\${var}\\`)`)\n * happens before entering the logger, but is very fast (~1μs per interpolation).\n */\nexport class Logger implements ILogger {\n    private instanceId: string;\n    private component: string;\n    private optionManager: IOptionManager;\n\n    // Cache the log level hierarchy to avoid array creation on every call\n    private static readonly LOG_LEVELS = [\n        \"error\",\n        \"warn\",\n        \"info\",\n        \"debug\",\n        \"trace\",\n    ];\n    private static readonly LOG_LEVEL_MAP: Record<string, number> = {\n        error: 0,\n        warn: 1,\n        info: 2,\n        debug: 3,\n        trace: 4,\n    };\n\n    constructor(\n        instanceId: string,\n        component: string,\n        optionManager: IOptionManager\n    ) {\n        this.instanceId = instanceId;\n        this.component = component;\n        this.optionManager = optionManager;\n    }\n\n    /**\n     * Fast check if logging should occur.\n     * This is called for EVERY log statement, so it must be extremely fast.\n     */\n    private shouldLog(level: string): boolean {\n        // Early exit - most important optimization!\n        // When debug is false, this returns immediately (1-2μs)\n        const debug = this.optionManager.getOption(\"debug\");\n        if (!debug) return false;\n\n        const logLevel = this.optionManager.getOption(\"logLevel\") || \"error\";\n\n        // Use map lookup instead of array indexOf (slightly faster)\n        const currentLevel = Logger.LOG_LEVEL_MAP[level] ?? 0;\n        const maxLevel = Logger.LOG_LEVEL_MAP[logLevel] ?? 0;\n\n        return currentLevel <= maxLevel;\n    }\n\n    private formatMessage(\n        level: string,\n        message: string,\n        ...args: any[]\n    ): string {\n        // Cache timestamp parts to avoid repeated ISO string operations\n        const timestamp = new Date().toISOString().split(\"T\")[1].slice(0, -1);\n        const shortId = this.instanceId.slice(-8);\n\n        // Only join args if there are any (avoid unnecessary operations)\n        const formattedMessage =\n            args.length > 0 ? `${message} ${args.join(\" \")}` : message;\n\n        return `${timestamp} [${level.toUpperCase()}] [${\n            this.component\n        }:${shortId}] ${formattedMessage}`;\n    }\n\n    /**\n     * Core logging method with performance optimizations:\n     * 1. Early exit if logging disabled (critical path)\n     * 2. Lazy formatting (only format if actually logging)\n     * 3. Console methods are async/non-blocking\n     */\n    private log(level: string, message: string, ...args: any[]): void {\n        // CRITICAL: Early exit before ANY expensive operations\n        // This is hit on EVERY log call in production\n        if (!this.shouldLog(level)) return;\n\n        // Only format message if we're actually going to log it\n        const formattedMessage = this.formatMessage(level, message, ...args);\n        const customLogger = this.optionManager.getOption(\"logger\");\n\n        if (customLogger) {\n            // Custom loggers are responsible for their own performance\n            // Consider wrapping in try-catch to prevent blocking on errors\n            try {\n                customLogger(level, formattedMessage, ...args);\n            } catch (error) {\n                // Fail silently to avoid blocking the main process\n                // Could optionally write to console.error as fallback\n            }\n            return;\n        }\n\n        // Console methods are non-blocking:\n        // - Browsers: Console output is queued and handled asynchronously\n        // - Node.js: stdout/stderr writes are mostly async (buffered)\n        // This means these calls return immediately and don't block the event loop\n        switch (level) {\n            case \"error\":\n                console.error(formattedMessage, ...args);\n                break;\n            case \"warn\":\n                console.warn(formattedMessage, ...args);\n                break;\n            case \"info\":\n                console.info(formattedMessage, ...args);\n                break;\n            case \"debug\":\n                console.log(formattedMessage, ...args);\n                break;\n            case \"trace\":\n                console.trace(formattedMessage, ...args);\n                break;\n        }\n    }\n\n    public error(message: string, ...args: any[]): void {\n        this.log(\"error\", message, ...args);\n    }\n\n    public warn(message: string, ...args: any[]): void {\n        this.log(\"warn\", message, ...args);\n    }\n\n    public info(message: string, ...args: any[]): void {\n        this.log(\"info\", message, ...args);\n    }\n\n    public debug(message: string, ...args: any[]): void {\n        this.log(\"debug\", message, ...args);\n    }\n\n    public trace(message: string, ...args: any[]): void {\n        this.log(\"trace\", message, ...args);\n    }\n}\n","import { EventListener } from \"../../types/events/listeners\";\n\n// Internal event map interface for type safety\ninterface EventMap {\n    [K: string]: any;\n}\n\n// Type helper for emit arguments\ntype EmitArgs<TEvents extends EventMap, K extends keyof TEvents> = \n    TEvents[K] extends void ? [] : [TEvents[K]];\n\nclass EventEmitter<TEvents extends EventMap = EventMap> {\n    private events: Map<string, Set<EventListener>>;\n\n    constructor() {\n        this.events = new Map();\n    }\n\n    public on(event: string, listener: EventListener): void {\n        if (!this.events.has(event)) {\n            this.events.set(event, new Set());\n        }\n        this.events.get(event)!.add(listener);\n    }\n\n    public off(event: string, listener: EventListener): void {\n        const listeners = this.events.get(event);\n        if (listeners) {\n            listeners.delete(listener);\n            if (listeners.size === 0) {\n                this.events.delete(event);\n            }\n        }\n    }\n\n    public once(event: string, listener: EventListener): void {\n        const onceWrapper = (...args: any[]) => {\n            listener(...args);\n            this.off(event, onceWrapper);\n        };\n        this.on(event, onceWrapper);\n    }\n\n    // Type-safe emit method - same name, just with optional typing\n    public emit<K extends keyof TEvents>(\n        event: K,\n        ...args: EmitArgs<TEvents, K>\n    ): void;\n    public emit(event: string, ...args: any[]): void;\n    public emit(event: string, ...args: any[]): void {\n        const listeners = this.events.get(event);\n        if (listeners) {\n            listeners.forEach((listener) => {\n                try {\n                    listener(...args);\n                } catch (error) {\n                    console.error(\n                        `Error in event listener for ${event}`,\n                        error\n                    );\n                }\n            });\n        }\n    }\n\n    public removeAllListeners(event?: string): void {\n        if (event) {\n            this.events.delete(event);\n        } else {\n            this.events.clear();\n        }\n    }\n\n    public listenerCount(event: string): number {\n        const listeners = this.events.get(event);\n        return listeners ? listeners.size : 0;\n    }\n\n    public eventNames(): string[] {\n        return Array.from(this.events.keys());\n    }\n}\n\nexport { EventEmitter };\n","export class Crypto {\n    private static async getSubtleCrypto(): Promise<SubtleCrypto> {\n        if (typeof window !== \"undefined\" && window.crypto) {\n            return window.crypto.subtle;\n        }\n\n        if (typeof global !== \"undefined\") {\n            try {\n                // Node.js v19+ has global.crypto\n                const crypto = (global as any).crypto;\n                if (crypto?.subtle) {\n                    return crypto.subtle;\n                }\n\n                // Older Node.js versions\n                const nodeCrypto = require(\"crypto\").webcrypto;\n                return nodeCrypto.subtle;\n            } catch {\n                throw new Error(\"Crypto is not supported in this environment\");\n            }\n        }\n\n        throw new Error(\"Crypto is not supported in this environment\");\n    }\n\n    static async hmacSign(data: string, key: string): Promise<string> {\n        try {\n            const subtle = await this.getSubtleCrypto();\n\n            // Convert key to raw bytes\n            const encoder = new TextEncoder();\n            const keyBytes = encoder.encode(key);\n            const dataBytes = encoder.encode(data);\n\n            // Import key\n            const cryptoKey = await subtle.importKey(\n                \"raw\",\n                keyBytes,\n                {\n                    name: \"HMAC\",\n                    hash: { name: \"SHA-256\" },\n                },\n                false,\n                [\"sign\"]\n            );\n\n            // Sign data\n            const signature = await subtle.sign(\"HMAC\", cryptoKey, dataBytes);\n\n            // Convert signature to base64\n            return this.arrayBufferToBase64(signature);\n        } catch (error) {\n            throw new Error(\n                `Signing failed: ${\n                    error instanceof Error ? error.message : \"Unknown error\"\n                }`\n            );\n        }\n    }\n\n    private static arrayBufferToBase64(buffer: ArrayBuffer): string {\n        if (typeof window !== \"undefined\") {\n            // Browser\n            const bytes = new Uint8Array(buffer);\n            const binary = bytes.reduce(\n                (str, byte) => str + String.fromCharCode(byte),\n                \"\"\n            );\n            return btoa(binary);\n        } else {\n            // Node.js\n            return Buffer.from(buffer).toString(\"base64\");\n        }\n    }\n}\n","import { JWTHeader, JWTPayload } from \"../../types/config/auth\";\nimport { Crypto } from \"./crypto\";\n\nexport class JWT {\n    static decode(token: string): { header: JWTHeader; payload: JWTPayload } {\n        try {\n            const [headerB64, payloadB64] = token.split(\".\");\n\n            const header = JSON.parse(atob(headerB64)) as JWTHeader;\n            const payload = JSON.parse(atob(payloadB64)) as JWTPayload;\n\n            // Validate required fields\n            if (!header.kid || !payload.alias || !payload.exp) {\n                throw new Error(\"Missing required JWT fields\");\n            }\n\n            return { header, payload };\n        } catch (e) {\n            throw new Error(\"Invalid JWT format\");\n        }\n    }\n\n    static isExpired(token: string): boolean {\n        try {\n            const { payload } = this.decode(token);\n            return payload.exp * 1000 <= Date.now();\n        } catch {\n            return true;\n        }\n    }\n\n    static async sign(\n        payload: JWTPayload,\n        apiKeyId: string,\n        privateKey: string\n    ): Promise<string> {\n        try {\n            const header: JWTHeader = {\n                alg: \"HS256\",\n                typ: \"JWT\",\n                kid: apiKeyId,\n            };\n\n            // Base64Url encode header and payload\n            const encodedHeader = this.base64UrlEncode(JSON.stringify(header));\n            const encodedPayload = this.base64UrlEncode(\n                JSON.stringify(payload)\n            );\n\n            // Create signature\n            const dataToSign = `${encodedHeader}.${encodedPayload}`;\n            const signature = await Crypto.hmacSign(dataToSign, privateKey);\n            const encodedSignature = this.base64UrlEncode(\n                this.base64Decode(signature)\n            );\n\n            return `${encodedHeader}.${encodedPayload}.${encodedSignature}`;\n        } catch (error) {\n            throw new Error(\n                `Failed to sign JWT: ${\n                    error instanceof Error ? error.message : \"Unknown error\"\n                }`\n            );\n        }\n    }\n\n    private static base64UrlEncode(str: string): string {\n        return btoa(str)\n            .replace(/\\+/g, \"-\")\n            .replace(/\\//g, \"_\")\n            .replace(/=+$/, \"\");\n    }\n\n    private static base64Decode(str: string): string {\n        return atob(str);\n    }\n}\n","export class ApiKey {\n    static parse(apiKey: string): { apiKeyId: string; privateKey: string } {\n        const [apiKeyId, privateKey] = apiKey.split(\":\");\n        if (!apiKeyId || !privateKey) {\n            throw new Error(\"Invalid API key format\");\n        }\n        return { apiKeyId, privateKey };\n    }\n}\n","/**\n * Event Constants\n * \n * Event names used throughout the SDK for the event emitter system.\n * These are distinct from protocol ActionTypes - they represent internal\n * state changes and notifications within the SDK.\n */\n\nexport const ConnectionEvents = {\n    INITIALIZED: \"initialized\",\n    CONNECTING: \"connecting\",\n    OPENED: \"opened\",\n    CONNECTED: \"connected\",\n    DISCONNECTED: \"disconnected\",\n    CLOSING: \"closing\",\n    CLOSED: \"closed\",\n    FAILED: \"failed\",\n} as const;\n\nexport type ConnectionEvent =\n    (typeof ConnectionEvents)[keyof typeof ConnectionEvents];\n\nexport const ChannelEvents = {\n    INITIALIZED: \"initialized\",\n    SUBSCRIBING: \"subscribing\",\n    SUBSCRIBED: \"subscribed\",\n    UNSUBSCRIBING: \"unsubscribing\",\n    UNSUBSCRIBED: \"unsubscribed\",\n    PAUSED: \"paused\",\n    RESUMED: \"resumed\",\n    FAILED: \"failed\",\n} as const;\n\nexport type ChannelEvent = (typeof ChannelEvents)[keyof typeof ChannelEvents];\n\nexport const AuthEvents = {\n    TOKEN_UPDATED: \"token_updated\",  // When a new token is set\n    TOKEN_EXPIRED: \"token_expired\",  // When current token expires\n    TOKEN_ERROR: \"token_error\",      // When token-related errors occur\n    AUTH_ERROR: \"auth_error\"         // When authentication fails\n} as const;\n\nexport type AuthEvent = typeof AuthEvents[keyof typeof AuthEvents];\n\n","import { EventEmitter } from \"../shared/event-emitter\";\nimport { AuthEventPayloads } from \"../../types/events/payloads\";\nimport {\n    IOptionManager,\n    IAuthManager,\n} from \"../../types/services/managers\";\nimport {\n    IHttpClient,\n    ILogger,\n} from \"../../types/services/clients\";\nimport { JWT } from \"../shared/jwt\";\nimport { JWTPayload } from \"../../types/config/auth\";\nimport {\n    AuthResponse,\n    TokenOptions,\n    TokenRequest,\n} from \"../../types/config/auth\";\nimport { Crypto } from \"../shared/crypto\";\nimport { ApiKey } from \"../shared/api-key\";\nimport { AuthEvents } from \"../../types/events/constants\";\n\nexport class AuthManager\n    extends EventEmitter<AuthEventPayloads>\n    implements IAuthManager\n{\n    private optionManager: IOptionManager;\n    private httpClient: IHttpClient;\n    private currentToken: string | null = null;\n    private refreshTimeout?: NodeJS.Timeout;\n    private logger: ILogger;\n    private _isResetting: boolean = false; // Add reset flag\n    private abortController: AbortController; // Add abort controller\n\n    constructor(\n        optionManager: IOptionManager,\n        httpClient: IHttpClient,\n        logger: ILogger\n    ) {\n        super();\n        this.optionManager = optionManager;\n        this.httpClient = httpClient;\n        this.logger = logger;\n        this.abortController = new AbortController();\n\n        this.logger.debug(\"AuthManager created\");\n\n        const tokenRequest = this.optionManager.getOption(\"tokenRequest\");\n        if (tokenRequest) {\n            this.logger.info(\"Initial token request found - requesting token\");\n            this.requestToken(tokenRequest).catch((error) => {\n                this.logger.error(\"Initial token request failed:\", error);\n                this.emit(AuthEvents.TOKEN_ERROR, {\n                    error:\n                        error instanceof Error\n                            ? error\n                            : new Error(\"Unknown error\"),\n                });\n            });\n        } else {\n            this.logger.debug(\"No initial token request provided\");\n        }\n    }\n\n    /**\n     * Unified error handler for auth manager\n     */\n    private handleError(error: unknown, context: string): never {\n        const formattedError =\n            error instanceof Error\n                ? new Error(`${context}: ${error.message}`)\n                : new Error(`${context}: Unknown error`);\n\n        this.logger.error(`${context}:`, error);\n\n        // Emit appropriate event based on context\n        if (context.includes(\"token\")) {\n            this.logger.debug(\"Emitting TOKEN_ERROR event\");\n            this.emit(AuthEvents.TOKEN_ERROR, { error: formattedError });\n        } else if (context.includes(\"auth\")) {\n            this.logger.debug(\"Emitting AUTH_ERROR event\");\n            this.emit(AuthEvents.AUTH_ERROR, {\n                error: formattedError,\n                context,\n            });\n        }\n\n        throw formattedError;\n    }\n\n    /**\n     * Authenticates the client with the provided credentials\n     * @returns Promise<string | null> The authenticated token or null if using apiKey directly\n     * @throws Error if no authentication credentials are provided\n     */\n    public async authenticate(): Promise<AuthResponse | null> {\n        this.logger.debug(\"Authenticate called\");\n\n        // Prevent authentication during reset\n        if (this._isResetting) {\n            this.logger.warn(\n                \"Authentication blocked - auth manager is resetting\"\n            );\n            return null;\n        }\n\n        const retries =\n            this.optionManager.getOption(\"authenticateRetries\") || 0;\n        const retryInterval =\n            this.optionManager.getOption(\"authenticateRetryIntervalMs\") || 1000;\n        const tokenRequest = this.optionManager.getOption(\"tokenRequest\");\n\n        this.logger.info(\n            `Starting authentication (retries: ${retries}, interval: ${retryInterval}ms)`\n        );\n\n        for (let attempt = 0; attempt <= retries; attempt++) {\n            try {\n                this.logger.debug(\n                    `Authentication attempt ${attempt + 1}/${retries + 1}`\n                );\n\n                // Check if reset was called during authentication\n                if (this._isResetting || this.abortController.signal.aborted) {\n                    this.logger.warn(\n                        \"Authentication cancelled - auth manager was reset or aborted\"\n                    );\n                    return null;\n                }\n\n                if (tokenRequest) {\n                    this.logger.debug(\"Using token request for authentication\");\n                    return await this.requestToken(tokenRequest);\n                }\n\n                const response = await this._authenticate();\n\n                if (response?.tokenRequest) {\n                    this.logger.debug(\n                        \"Received token request in response - requesting token\"\n                    );\n                    return await this.requestToken(response.tokenRequest);\n                }\n\n                this.logger.info(\"Authentication successful\");\n                return response;\n            } catch (error) {\n                // Check if operation was aborted\n                if (this.abortController.signal.aborted) {\n                    this.logger.warn(\"Authentication cancelled due to abort\");\n                    return null;\n                }\n\n                const isLastAttempt = attempt === retries;\n                this.logger.warn(\n                    `Authentication attempt ${attempt + 1}/${retries + 1} failed:`,\n                    error\n                );\n\n                if (isLastAttempt) {\n                    this.logger.error(\"All authentication attempts failed\");\n                    return this.handleError(error, \"Authentication failed\");\n                }\n\n                this.logger.debug(\n                    `Retrying authentication in ${retryInterval}ms`\n                );\n                await new Promise((resolve) =>\n                    setTimeout(resolve, retryInterval)\n                );\n            }\n        }\n\n        return null;\n    }\n\n    private async _authenticate(): Promise<AuthResponse | null> {\n        this.logger.debug(\"Internal authentication started\");\n\n        const authUrl = this.optionManager.getOption(\"authUrl\");\n        const apiKey = this.optionManager.getOption(\"apiKey\");\n        const authOptions = this.optionManager.getOption(\"authOptions\");\n\n        this.logger.trace(\"Auth config:\", {\n            hasAuthUrl: !!authUrl,\n            hasApiKey: !!apiKey,\n            hasAuthOptions: !!authOptions,\n        });\n\n        if (!authUrl && !apiKey) {\n            this.logger.error(\"No authentication credentials provided\");\n            return this.handleError(\n                new Error(\"Either authUrl or apiKey must be provided\"),\n                \"Authentication failed\"\n            );\n        }\n\n        if (!authUrl) {\n            this.logger.debug(\n                \"No authUrl provided - will use apiKey for authentication\"\n            );\n            return null; // Will use apiKey for authentication\n        }\n\n        this.logger.debug(`Sending auth request to: ${authUrl}`);\n\n        const response = await this.httpClient.post<AuthResponse>(\n            authUrl,\n            authOptions?.body || {},\n            {\n                ...authOptions?.headers,\n            }\n        );\n\n        this.logger.debug(\"Received auth response\");\n\n        if (response.token) {\n            this.logger.debug(\"Response contains token - decoding and setting\");\n            JWT.decode(response.token);\n            this.setToken(response.token);\n            return response;\n        }\n\n        if (response.tokenRequest) {\n            this.logger.debug(\"Response contains token request\");\n            return response;\n        }\n\n        this.logger.error(\"Invalid auth response - no token or tokenRequest\");\n        return this.handleError(\n            new Error(\"Invalid response: expected token or tokenRequest\"),\n            \"Authentication failed\"\n        );\n    }\n\n    /**\n     * Check if auto authentication is enabled\n     */\n    public shouldAutoAuthenticate(): boolean {\n        const autoAuth =\n            this.optionManager.getOption(\"autoAuthenticate\") ?? true;\n        this.logger.trace(`shouldAutoAuthenticate: ${autoAuth}`);\n        return autoAuth;\n    }\n\n    private setToken(token: string): void {\n        this.logger.debug(\"Setting new token\");\n        this.currentToken = token;\n        const decoded = JWT.decode(token);\n\n        const expiresAt = decoded?.payload?.exp\n            ? new Date(decoded.payload.exp * 1000)\n            : undefined;\n\n        if (expiresAt) {\n            this.logger.info(\n                `Token set - expires at ${expiresAt.toISOString()}`\n            );\n        } else {\n            this.logger.info(\"Token set - no expiration\");\n        }\n\n        this.logger.debug(\"Emitting TOKEN_UPDATED event\");\n        this.emit(AuthEvents.TOKEN_UPDATED, { token, expiresAt });\n        this.scheduleTokenRefresh(token);\n    }\n\n    public getToken(): string | null {\n        this.logger.trace(\"getToken called\");\n\n        if (this.currentToken && !JWT.isExpired(this.currentToken)) {\n            this.logger.trace(\"Returning valid token\");\n            return this.currentToken;\n        }\n\n        if (this.currentToken) {\n            this.logger.warn(\"Current token has expired\");\n            this.emit(AuthEvents.TOKEN_EXPIRED, {\n                expiredAt: new Date(),\n                token: this.currentToken,\n            });\n            this.clearToken();\n        } else {\n            this.logger.trace(\"No token available\");\n        }\n\n        return null;\n    }\n\n    private scheduleTokenRefresh(token: string): void {\n        this.logger.debug(\"Scheduling token refresh\");\n\n        if (this.refreshTimeout) {\n            this.logger.debug(\"Clearing existing refresh timeout\");\n            clearTimeout(this.refreshTimeout);\n        }\n\n        try {\n            const { payload } = JWT.decode(token);\n            const buffer = 60000; // 1 minute buffer\n            const delay = payload.exp * 1000 - Date.now() - buffer;\n\n            if (delay > 0) {\n                const refreshDate = new Date(Date.now() + delay);\n                this.logger.info(\n                    `Token refresh scheduled for ${refreshDate.toISOString()} (in ${Math.round(delay / 1000)}s)`\n                );\n                this.refreshTimeout = setTimeout(() => {\n                    this.logger.info(\n                        \"Token refresh timer triggered - clearing token\"\n                    );\n                    this.emit(AuthEvents.TOKEN_EXPIRED, {\n                        expiredAt: new Date(),\n                    });\n                    this.clearToken();\n                }, delay);\n            } else {\n                this.logger.warn(\n                    `Token already expired or about to expire (delay: ${delay}ms)`\n                );\n                this.emit(AuthEvents.TOKEN_EXPIRED, { expiredAt: new Date() });\n                this.clearToken();\n            }\n        } catch (error) {\n            this.logger.error(\"Error scheduling token refresh:\", error);\n            this.emit(AuthEvents.TOKEN_ERROR, {\n                error:\n                    error instanceof Error ? error : new Error(\"Unknown error\"),\n            });\n            this.clearToken();\n        }\n    }\n\n    public clearToken(): void {\n        this.logger.debug(\"Clearing token\");\n        this.currentToken = null;\n        if (this.refreshTimeout) {\n            this.logger.debug(\"Clearing refresh timeout\");\n            clearTimeout(this.refreshTimeout);\n            this.refreshTimeout = undefined;\n        }\n        this.logger.info(\"Token cleared\");\n    }\n\n    public getAuthHeaders(): HeadersInit {\n        this.logger.trace(\"Getting auth headers\");\n\n        const apiKey = this.optionManager.getOption(\"apiKey\");\n        const token = this.getToken();\n        const alias = this.optionManager.getOption(\"alias\");\n\n        if (token) {\n            this.logger.debug(\"Using Bearer token for auth headers\");\n            return {\n                Authorization: `Bearer ${token}`,\n            };\n        } else if (apiKey) {\n            this.logger.debug(\n                `Using Basic auth for auth headers${alias ? \" with alias\" : \"\"}`\n            );\n            const headers: HeadersInit = {\n                Authorization: `Basic ${btoa(apiKey)}`,\n            };\n\n            // Add alias header for basic auth if provided\n            if (alias) {\n                headers[\"X-Alias\"] = alias;\n            }\n\n            return headers;\n        }\n\n        this.logger.error(\n            \"No authentication credentials available for headers\"\n        );\n        return this.handleError(\n            new Error(\"No authentication credentials provided\"),\n            \"No authentication credentials provided\"\n        );\n    }\n\n    public getAuthQueryParams(): string {\n        this.logger.trace(\"Getting auth query params\");\n\n        const apiKey = this.optionManager.getOption(\"apiKey\");\n        const token = this.getToken();\n        const alias = this.optionManager.getOption(\"alias\");\n\n        if (token) {\n            this.logger.debug(\"Using access_token for query params\");\n            return `access_token=${encodeURIComponent(token)}`;\n        } else if (apiKey) {\n            this.logger.debug(\n                `Using api_key for query params${alias ? \" with alias\" : \"\"}`\n            );\n            let params = `api_key=${encodeURIComponent(apiKey)}`;\n\n            // Add alias query param for basic auth if provided\n            if (alias) {\n                params += `&alias=${encodeURIComponent(alias)}`;\n            }\n\n            return params;\n        }\n\n        this.logger.error(\n            \"No authentication credentials available for query params\"\n        );\n        return this.handleError(\n            new Error(\"No authentication credentials available\"),\n            \"No authentication credentials available\"\n        );\n    }\n\n    public getAuthenticateUrl(baseUrl: string): string {\n        this.logger.debug(`Building authenticate URL for: ${baseUrl}`);\n        const authQueryParams = this.getAuthQueryParams();\n        const separator = baseUrl.includes(\"?\") ? \"&\" : \"?\";\n        const url = `${baseUrl}${separator}${authQueryParams}`;\n        this.logger.trace(`Authenticate URL built: ${url.substring(0, 50)}...`);\n        return url;\n    }\n\n    /**\n     * Generates a QPub-compatible JWT token\n     * Medium-low level of security\n     * Should be called from server-side only\n     * Note: The permissions are not validated by the server, so make sure to set the correct permissions that align with the API key or use the issueToken method instead\n     * @param options - Token options\n     * @returns Promise<string> The generated JWT token\n     * @throws Error if apiKey is not provided or signing fails\n     */\n    public async generateToken(options: TokenOptions = {}): Promise<string> {\n        this.logger.debug(\"Generating token\", options);\n\n        const apiKey = this.optionManager.getOption(\"apiKey\");\n\n        if (!apiKey) {\n            this.logger.error(\"Cannot generate token - no API key provided\");\n            return this.handleError(\n                new Error(\"API key is required\"),\n                \"Token generation failed\"\n            );\n        }\n\n        try {\n            const { apiKeyId, privateKey } = ApiKey.parse(apiKey);\n            this.logger.debug(`Parsed API key - keyId: ${apiKeyId}`);\n\n            const expiresIn = options.expiresIn || 3600;\n            const payload: JWTPayload = {\n                exp: Math.floor(Date.now() / 1000) + expiresIn,\n            };\n\n            if (options.alias !== undefined) {\n                payload.alias = options.alias;\n                this.logger.debug(`Token alias: ${options.alias}`);\n            }\n\n            if (options.permissions !== undefined) {\n                payload.permissions = options.permissions;\n                this.logger.debug(\"Token permissions set\");\n            }\n\n            this.logger.debug(`Signing token (expires in ${expiresIn}s)`);\n            const token = await JWT.sign(payload, apiKeyId, privateKey);\n\n            this.logger.info(\"Token generated successfully\");\n            return token;\n        } catch (error) {\n            this.logger.error(\"Token generation failed:\", error);\n            return this.handleError(error, \"Token generation failed\");\n        }\n    }\n\n    /**\n     * Issues a new JWT token from QPub server\n     * Medium level of security\n     * Should be called from server-side only\n     * @param options - Token options\n     * @returns Promise<string> The issued JWT token\n     * @throws Error if apiKey is not provided or token request fails\n     */\n    public async issueToken(options: TokenOptions = {}): Promise<string> {\n        this.logger.debug(\"Issuing token from QPub server\", options);\n\n        const apiKey = this.optionManager.getOption(\"apiKey\");\n\n        if (!apiKey) {\n            this.logger.error(\"Cannot issue token - no API key provided\");\n            return this.handleError(\n                new Error(\"API key is required for issuing tokens\"),\n                \"Token issuance failed\"\n            );\n        }\n\n        try {\n            const { apiKeyId } = ApiKey.parse(apiKey);\n            this.logger.debug(`Parsed API key - keyId: ${apiKeyId}`);\n\n            const host = this.optionManager.getOption(\"httpHost\");\n            const port = this.optionManager.getOption(\"httpPort\");\n            const isSecure = this.optionManager.getOption(\"isSecure\");\n            const protocol = isSecure ? \"https\" : \"http\";\n            const baseUrl = `${protocol}://${host}${port ? `:${port}` : \"\"}/v1`;\n            const url = `${baseUrl}/key/${apiKeyId}/token/issue`;\n\n            this.logger.debug(`Issuing token from: ${url}`);\n\n            const response = await this.httpClient.post<{ token: string }>(\n                url,\n                options,\n                {\n                    Authorization: `Basic ${btoa(apiKey)}`,\n                }\n            );\n\n            if (!response.token) {\n                this.logger.error(\"Invalid token response - no token field\");\n                return this.handleError(\n                    new Error(\"Invalid token response from QPub server\"),\n                    \"Token issuance failed\"\n                );\n            }\n\n            this.logger.debug(\"Token received - decoding to validate\");\n            JWT.decode(response.token);\n\n            this.logger.info(\"Token issued successfully from QPub server\");\n            return response.token;\n        } catch (error) {\n            this.logger.error(\"Token issuance failed:\", error);\n            return this.handleError(error, \"Token issuance failed\");\n        }\n    }\n\n    /**\n     * Creates a token request object for client-side token requests\n     * High level of security\n     * Should be called from server-side only\n     * @param options - Token request options\n     * @returns Promise<TokenRequest> Object to be used by client for token request\n     * @throws Error if apiKey is not provided or signing fails\n     */\n    public async createTokenRequest(\n        options: TokenOptions = {}\n    ): Promise<TokenRequest> {\n        this.logger.debug(\"Creating token request\", options);\n\n        const apiKey = this.optionManager.getOption(\"apiKey\");\n\n        if (!apiKey) {\n            this.logger.error(\n                \"Cannot create token request - no API key provided\"\n            );\n            return this.handleError(\n                new Error(\"API key is required for creating token requests\"),\n                \"Token request creation failed\"\n            );\n        }\n\n        try {\n            const { apiKeyId, privateKey } = ApiKey.parse(apiKey);\n            this.logger.debug(`Parsed API key - keyId: ${apiKeyId}`);\n\n            const timestamp = Math.floor(Date.now() / 1000);\n\n            // Create signature data based on provided options\n            let dataToSign = `${apiKeyId}.${timestamp}`;\n            if (options.alias !== undefined) {\n                dataToSign += `.${options.alias}`;\n                this.logger.debug(`Token request alias: ${options.alias}`);\n            }\n            if (options.permissions !== undefined) {\n                dataToSign += `.${JSON.stringify(options.permissions)}`;\n                this.logger.debug(\"Token request permissions set\");\n            }\n\n            this.logger.debug(\"Signing token request data\");\n            const signature = await Crypto.hmacSign(dataToSign, privateKey);\n\n            const request: TokenRequest = {\n                kid: apiKeyId,\n                timestamp,\n                signature,\n            };\n\n            if (options.alias !== undefined) {\n                request.alias = options.alias;\n            }\n            if (options.permissions !== undefined) {\n                request.permissions = options.permissions;\n            }\n\n            this.logger.info(\"Token request created successfully\");\n            return request;\n        } catch (error) {\n            this.logger.error(\"Token request creation failed:\", error);\n            return this.handleError(error, \"Token request creation failed\");\n        }\n    }\n\n    /**\n     * Requests a token from QPub server using a TokenRequest\n     * Should be called from client-side only\n     * @param request - The token request object from auth server\n     * @returns Promise<AuthResponse> QPub server's response containing the token\n     */\n    public async requestToken(request: TokenRequest): Promise<AuthResponse> {\n        this.logger.debug(\"Requesting token from QPub server\", {\n            kid: request.kid,\n            hasAlias: !!request.alias,\n            hasPermissions: !!request.permissions,\n        });\n\n        try {\n            const host = this.optionManager.getOption(\"httpHost\");\n            const port = this.optionManager.getOption(\"httpPort\");\n            const isSecure = this.optionManager.getOption(\"isSecure\");\n            const protocol = isSecure ? \"https\" : \"http\";\n            const baseUrl = `${protocol}://${host}${port ? `:${port}` : \"\"}/v1`;\n            const url = `${baseUrl}/key/${request.kid}/token/request`;\n\n            this.logger.debug(`Sending token request to: ${url}`);\n\n            const response = await this.httpClient.post<AuthResponse>(\n                url,\n                request,\n                {\n                    \"Content-Type\": \"application/json\",\n                }\n            );\n\n            if (!response.token) {\n                this.logger.error(\"Invalid token response - no token field\");\n                return this.handleError(\n                    new Error(\"Invalid response: token not found\"),\n                    \"Token request failed\"\n                );\n            }\n\n            this.logger.debug(\"Token received - decoding and setting\");\n            JWT.decode(response.token);\n            this.setToken(response.token);\n\n            this.logger.info(\"Token request successful\");\n            return response;\n        } catch (error) {\n            this.logger.error(\"Token request failed:\", error);\n            return this.handleError(error, \"Token request failed\");\n        }\n    }\n\n    public isAuthenticated(): boolean {\n        const authenticated = this.currentToken !== null;\n        this.logger.trace(`isAuthenticated: ${authenticated}`);\n        return authenticated;\n    }\n\n    public getCurrentToken(): string | null {\n        this.logger.trace(\"getCurrentToken called\");\n        return this.currentToken;\n    }\n\n    public reset(): void {\n        this.logger.info(\"Resetting auth manager\");\n\n        // 1. Set reset flag to prevent new operations\n        this.logger.debug(\"Setting reset flag\");\n        this._isResetting = true;\n\n        // 2. Abort all pending operations\n        this.logger.debug(\"Aborting pending operations\");\n        this.abortController.abort();\n\n        // 3. Create new abort controller for future operations\n        this.logger.debug(\"Creating new abort controller\");\n        this.abortController = new AbortController();\n\n        // 4. Clear token and timers\n        this.logger.debug(\"Clearing token and timers\");\n        this.clearToken();\n\n        // 5. Remove all listeners\n        this.logger.debug(\"Removing all event listeners\");\n        this.removeAllListeners();\n\n        // 6. Reset the reset flag to allow new operations\n        this.logger.debug(\"Clearing reset flag\");\n        this._isResetting = false;\n\n        this.logger.info(\"Auth manager reset complete\");\n    }\n\n    // Getter for abort signal\n    public getAbortSignal(): AbortSignal {\n        this.logger.trace(\"getAbortSignal called\");\n        return this.abortController.signal;\n    }\n}\n","import { QPubWebSocket } from \"../../types/services/websocket\";\nimport { IWebSocketClient, ILogger } from \"../../types/services/clients\";\n\nexport class WebSocketClient implements IWebSocketClient {\n    private socket: QPubWebSocket | null = null;\n    private WebSocketImplementation: any;\n    private logger: ILogger;\n\n    constructor(logger: ILogger) {\n        this.logger = logger;\n\n        if (typeof window !== \"undefined\" && window.WebSocket) {\n            this.WebSocketImplementation = window.WebSocket;\n        } else {\n            try {\n                this.WebSocketImplementation = require(\"ws\");\n            } catch (e) {\n                this.logger.error(\n                    \"WebSocket is not supported in this environment\"\n                );\n                throw new Error(\n                    \"WebSocket is not supported in this environment\"\n                );\n            }\n        }\n    }\n\n    public getSocket(): QPubWebSocket | null {\n        return this.socket;\n    }\n\n    public connect(url: string): void {\n        if (this.socket) {\n            this.logger.info(\"Closing existing WebSocket connection\");\n            this.disconnect();\n        }\n\n        this.logger.info(`Connecting to WebSocket at ${url}`);\n        this.socket = new this.WebSocketImplementation(url) as QPubWebSocket;\n\n        this.socket.onerror = (error: Event) => {\n            this.logger.error(\"WebSocket error:\", error);\n            // Don't disconnect here - let the Connection class handle it\n        };\n    }\n\n    public isConnected(): boolean {\n        return (\n            this.socket !== null && this.socket.readyState === WebSocket.OPEN\n        );\n    }\n\n    public disconnect(): void {\n        if (this.socket) {\n            if (this.socket.readyState < WebSocket.CLOSING) {\n                try {\n                    this.logger.info(\"Closing WebSocket connection\");\n                    this.socket.close();\n                } catch (error) {\n                    this.logger.error(\"Error closing socket:\", error);\n                }\n            }\n            this.socket = null;\n        }\n    }\n\n    public send(data: string | ArrayBufferLike | Blob | ArrayBufferView): void {\n        if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {\n            this.logger.error(\"Attempted to send data on a closed WebSocket\");\n            throw new Error(\"WebSocket is not connected\");\n        }\n        this.logger.debug(`Sending data: ${data}`);\n        this.socket.send(data);\n    }\n\n    public reset(): void {\n        this.logger.info(\"Resetting WebSocketClient instance\");\n        // In the normal case, the connection will be closed by the Connection class when it is reset\n        // However, in the case of direct reset, we need to disconnect the socket\n        if (this.isConnected()) {\n            this.disconnect();\n        }\n    }\n}\n","import { Channel } from \"../../types/services/channel\";\nimport { EventEmitter } from \"../shared/event-emitter\";\nimport { ChannelEventPayloads } from \"../../types/events/payloads\";\nimport { ChannelEvents } from \"../../types/events/constants\";\n\nexport abstract class BaseChannel extends EventEmitter<ChannelEventPayloads> implements Channel {\n    public readonly name: string;\n\n    constructor(name: string) {\n        super();\n        this.name = name;\n        this.emit(ChannelEvents.INITIALIZED, { channelName: name });\n    }\n\n    public getName(): string {\n        return this.name;\n    }\n\n    abstract publish(message: any): Promise<void>;\n\n    abstract reset(): void;\n}\n","import { ActionType } from \"../../types/protocol/actions\";\nimport { BaseChannel } from \"./channel\";\nimport { IWebSocketClient, ILogger } from \"../../types/services/clients\";\nimport { ChannelEvents } from \"../../types/events/constants\";\nimport {\n    OutgoingChannelMessage,\n    DataMessagePayload,\n    IncomingDataMessage,\n    OutgoingDataMessage,\n    Message,\n} from \"../../types/protocol/messages\";\nimport {\n    PublishOptions,\n    SubscribeOptions,\n} from \"../../types/services/channel\";\n\n// Operation types for the queue\ninterface SubscribeOperation {\n    type: \"subscribe\";\n    callback: (message: Message) => void;\n    options?: SubscribeOptions;\n}\n\ninterface UnsubscribeOperation {\n    type: \"unsubscribe\";\n    callback?: (message: Message) => void;\n    options?: SubscribeOptions;\n}\n\ntype QueuedOperation = SubscribeOperation | UnsubscribeOperation;\n\nexport class SocketChannel extends BaseChannel {\n    private wsClient: IWebSocketClient;\n    private logger: ILogger;\n    private subscribed: boolean = false;\n    private pendingSubscribe: boolean = false;\n    private pendingUnsubscribe: boolean = false;\n    private operationQueue: QueuedOperation[] = [];\n    private paused: boolean = false;\n    private pausedMessages: Message[] = [];\n    private bufferWhilePaused: boolean = true;\n    private messageCallback?: (message: Message) => void;\n    private messageHandler: (event: MessageEvent) => void;\n    private eventCallbacks: Map<string, Set<(message: Message) => void>> =\n        new Map();\n    private pendingTimeouts: Set<NodeJS.Timeout> = new Set();\n\n    constructor(name: string, wsClient: IWebSocketClient, logger: ILogger) {\n        super(name);\n        this.wsClient = wsClient;\n        this.logger = logger;\n        this.logger.debug(`SocketChannel created for: ${name}`);\n\n        // Create the message handler function ONCE - never recreate it\n        this.messageHandler = (event) => {\n            try {\n                const message = JSON.parse(event.data);\n                if (message.channel === this.name) {\n                    this.logger.trace(\n                        `Received message for channel ${this.name}:`,\n                        message\n                    );\n                    this.handleMessage(message);\n                }\n            } catch (error) {\n                this.logger.error(\n                    `Error parsing message for channel ${this.name}:`,\n                    error\n                );\n                this.emit(ChannelEvents.FAILED, {\n                    channelName: this.name,\n                    error:\n                        error instanceof Error\n                            ? error\n                            : new Error(\"Unknown error\"),\n                    action: \"message_parsing\",\n                });\n            }\n        };\n\n        this.setupMessageHandler();\n    }\n\n    private setupMessageHandler(): void {\n        const socket = this.wsClient.getSocket();\n        if (!socket) {\n            this.logger.warn(\n                `Cannot setup message handler - socket not available for channel: ${this.name}`\n            );\n            return;\n        }\n\n        this.logger.debug(\n            `Setting up message handler for channel: ${this.name}`\n        );\n\n        // Remove if already attached (idempotent)\n        socket.removeEventListener(\"message\", this.messageHandler);\n\n        // Attach the handler\n        socket.addEventListener(\"message\", this.messageHandler);\n        this.logger.debug(\n            `Message handler attached to socket for channel: ${this.name}`\n        );\n    }\n\n    /**\n     * Processes the next operation in the queue if the channel is in a stable state.\n     * This is called after receiving SUBSCRIBED or UNSUBSCRIBED acknowledgments.\n     */\n    private processOperationQueue(): void {\n        // Only process queue if we're in a stable state (no pending operations)\n        if (this.pendingSubscribe || this.pendingUnsubscribe) {\n            this.logger.debug(\n                `Channel ${this.name} has pending operations - deferring queue processing`\n            );\n            return;\n        }\n\n        if (this.operationQueue.length === 0) {\n            return;\n        }\n\n        const operation = this.operationQueue.shift()!;\n        this.logger.info(\n            `Processing queued ${operation.type} operation for channel: ${this.name} (${this.operationQueue.length} remaining in queue)`\n        );\n\n        if (operation.type === \"subscribe\") {\n            this.executeSubscribe(operation.callback, operation.options);\n        } else {\n            this.executeUnsubscribe(operation.callback, operation.options);\n        }\n    }\n\n    /**\n     * Transforms an IncomingDataMessage to an array of consumer Message objects.\n     * Each DataMessagePayload in the messages array becomes a separate Message.\n     */\n    private transformToConsumerMessages(\n        incomingMessage: IncomingDataMessage\n    ): Message[] {\n        const { id, timestamp, channel, action, error, messages } =\n            incomingMessage;\n\n        this.logger.trace(\n            `Transforming ${messages.length} message(s) for channel ${this.name}`\n        );\n\n        return messages.map(\n            (messagePayload, index): Message => ({\n                // Base message fields\n                action,\n                error,\n                // Container message fields - suffix ID with index for batch messages\n                id: messages.length > 1 ? `${id}-${index}` : id,\n                timestamp,\n                channel,\n                // Individual message payload fields\n                alias: messagePayload.alias,\n                event: messagePayload.event,\n                data: messagePayload.data,\n            })\n        );\n    }\n\n    private handleMessage(message: any): void {\n        this.logger.debug(\n            `Handling message action ${message.action} for channel: ${this.name}`\n        );\n\n        switch (message.action) {\n            case ActionType.MESSAGE:\n                if (this.isSubscribed()) {\n                    const incomingDataMessage = message as IncomingDataMessage;\n                    const consumerMessages =\n                        this.transformToConsumerMessages(incomingDataMessage);\n\n                    if (this.paused) {\n                        if (this.bufferWhilePaused) {\n                            this.logger.debug(\n                                `Channel ${this.name} is paused - buffering ${consumerMessages.length} message(s)`\n                            );\n                            this.pausedMessages.push(...consumerMessages);\n                        } else {\n                            this.logger.debug(\n                                `Channel ${this.name} is paused - dropping ${consumerMessages.length} message(s)`\n                            );\n                        }\n                    } else {\n                        this.logger.debug(\n                            `Dispatching ${consumerMessages.length} message(s) to callback for channel: ${this.name}`\n                        );\n                        // Call the callback for each individual message\n                        consumerMessages.forEach((consumerMessage) => {\n                            this.messageCallback?.(consumerMessage);\n                        });\n                    }\n                } else {\n                    this.logger.warn(\n                        `Received message for channel ${this.name} but not subscribed - ignoring`\n                    );\n                }\n                break;\n\n            case ActionType.SUBSCRIBED:\n                this.logger.debug(\n                    `Received SUBSCRIBED confirmation for channel: ${this.name}`\n                );\n                this.subscribed = true;\n                this.pendingSubscribe = false;\n                this.logger.info(\n                    `Channel ${this.name} subscribed successfully (subscription ID: ${message.subscription_id})`\n                );\n                this.emit(ChannelEvents.SUBSCRIBED, {\n                    channelName: this.name,\n                    subscriptionId: message.subscription_id || \"\",\n                });\n                // Process any queued operations now that subscribe completed\n                this.logger.debug(\n                    `Processing operation queue after subscription (${this.operationQueue.length} operations queued)`\n                );\n                this.processOperationQueue();\n                break;\n\n            case ActionType.UNSUBSCRIBED:\n                this.logger.debug(\n                    `Received UNSUBSCRIBED confirmation for channel: ${this.name}`\n                );\n                this.subscribed = false;\n                this.pendingSubscribe = false;\n                this.pendingUnsubscribe = false;\n                this.messageCallback = undefined;\n                this.eventCallbacks.clear();\n                this.logger.info(\n                    `Channel ${this.name} unsubscribed (subscription ID: ${message.subscription_id})`\n                );\n                this.emit(ChannelEvents.UNSUBSCRIBED, {\n                    channelName: this.name,\n                    subscriptionId: message.subscription_id,\n                });\n                // Process any queued operations now that unsubscribe completed\n                this.logger.debug(\n                    `Processing operation queue after unsubscription (${this.operationQueue.length} operations queued)`\n                );\n                this.processOperationQueue();\n                break;\n\n            case ActionType.ERROR:\n                this.logger.error(\n                    `Channel ${this.name} received error:`,\n                    message.error\n                );\n                this.emit(ChannelEvents.FAILED, {\n                    channelName: this.name,\n                    error: message.error || new Error(\"Unknown channel error\"),\n                    action: \"channel_operation\",\n                });\n                break;\n\n            default:\n                this.logger.warn(\n                    `Unknown action type ${message.action} received for channel: ${this.name}`\n                );\n        }\n    }\n\n    /**\n     * Publish a message to the channel.\n     * Note: This is a fire-and-forget operation - no server acknowledgment is expected.\n     * The Promise resolves immediately after sending, not after delivery confirmation.\n     */\n    public async publish(data: any, options?: PublishOptions): Promise<void> {\n        this.logger.debug(\n            `Publishing to channel ${this.name}${options?.event ? ` (event: ${options.event})` : \"\"}${options?.alias ? ` (alias: ${options.alias})` : \"\"}`\n        );\n\n        if (!this.wsClient.isConnected()) {\n            const error = new Error(\n                \"Cannot publish: WebSocket is not connected\"\n            );\n            this.logger.error(\n                `Publish failed for channel ${this.name}:`,\n                error\n            );\n            throw error;\n        }\n\n        try {\n            const messagePayload: DataMessagePayload = {\n                data,\n                event: options?.event,\n                alias: options?.alias,\n            };\n\n            const publishMessage: OutgoingDataMessage = {\n                action: ActionType.PUBLISH,\n                channel: this.name,\n                messages: [messagePayload],\n            };\n\n            this.logger.trace(\n                `Sending publish message for channel ${this.name}:`,\n                publishMessage\n            );\n            this.wsClient.send(JSON.stringify(publishMessage));\n            this.logger.info(`Published message to channel: ${this.name}`);\n        } catch (error) {\n            this.logger.error(\n                `Error publishing to channel ${this.name}:`,\n                error\n            );\n            this.emit(ChannelEvents.FAILED, {\n                channelName: this.name,\n                error:\n                    error instanceof Error ? error : new Error(\"Unknown error\"),\n                action: \"publish\",\n            });\n            throw error;\n        }\n    }\n\n    /**\n     * Subscribe to channel messages. Returns a Promise that resolves when subscription is confirmed.\n     * Can be used with or without await:\n     * - Fire-and-forget: channel.subscribe(callback)\n     * - Wait for confirmation: await channel.subscribe(callback)\n     */\n    public async subscribe(\n        callback: (message: Message) => void,\n        options?: SubscribeOptions & { timeout?: number }\n    ): Promise<void> {\n        const timeout = options?.timeout || 10000; // Default 10s timeout\n\n        this.logger.debug(\n            `Subscribe requested for channel: ${this.name} (subscribed: ${this.subscribed}, event: ${options?.event}, pendingSubscribe: ${this.pendingSubscribe}, pendingUnsubscribe: ${this.pendingUnsubscribe})`\n        );\n\n        if (!this.wsClient.isConnected()) {\n            this.pendingSubscribe = true;\n            const error = new Error(\n                \"Cannot subscribe: WebSocket is not connected\"\n            );\n            this.logger.error(\n                `Subscribe failed for channel ${this.name}:`,\n                error\n            );\n            throw error;\n        }\n\n        // Determine if we need to wait for network confirmation\n        let needsNetworkConfirmation = false;\n        let willQueue = false;\n\n        // Special handling for event-specific subscriptions:\n        // They can proceed if the channel is already subscribed or subscribing\n        // (unless an unsubscribe is pending)\n        // because they just add to the event callbacks map\n        if (options?.event) {\n            // If unsubscribe is pending, we must queue\n            if (this.pendingUnsubscribe) {\n                this.logger.info(\n                    `Queueing event subscribe operation for channel ${this.name} (pendingUnsubscribe: ${this.pendingUnsubscribe})`\n                );\n                this.operationQueue.push({\n                    type: \"subscribe\",\n                    callback,\n                    options,\n                });\n                willQueue = true;\n                needsNetworkConfirmation = true;\n            }\n            // Channel is already subscribed or subscribing, just add the event callback\n            else if (this.isSubscribed() || this.pendingSubscribe) {\n                this.executeSubscribe(callback, options);\n                return Promise.resolve();\n            } else {\n                // Need to subscribe to channel\n                needsNetworkConfirmation = true;\n            }\n        } else {\n            // Catch-all subscription - must wait for any pending operations\n            if (this.pendingUnsubscribe || this.pendingSubscribe) {\n                this.logger.info(\n                    `Queueing subscribe operation for channel ${this.name} (pendingUnsubscribe: ${this.pendingUnsubscribe}, pendingSubscribe: ${this.pendingSubscribe})`\n                );\n                this.operationQueue.push({\n                    type: \"subscribe\",\n                    callback,\n                    options,\n                });\n                willQueue = true;\n                needsNetworkConfirmation = true;\n            } else if (this.isSubscribed()) {\n                // Just updating callback, no network call\n                this.executeSubscribe(callback, options);\n                return Promise.resolve();\n            } else {\n                // Need to subscribe to channel\n                needsNetworkConfirmation = true;\n            }\n        }\n\n        if (!needsNetworkConfirmation) {\n            // Can execute immediately without waiting\n            this.executeSubscribe(callback, options);\n            return Promise.resolve();\n        }\n\n        // Need to wait for network confirmation\n        return new Promise<void>((resolve, reject) => {\n            const handleSubscribed = () => {\n                cleanup();\n                this.logger.debug(\n                    `Subscribe resolved for channel: ${this.name}`\n                );\n                resolve();\n            };\n\n            const handleFailed = (event: any) => {\n                cleanup();\n                this.logger.error(\n                    `Subscribe rejected for channel: ${this.name}`,\n                    event.error\n                );\n                reject(event.error);\n            };\n\n            const timeoutId = setTimeout(() => {\n                cleanup();\n                const error = new Error(\n                    `Subscription timeout after ${timeout}ms for channel: ${this.name}`\n                );\n                this.logger.error(error.message);\n                reject(error);\n            }, timeout);\n\n            // Track the timeout so it can be cleaned up\n            this.pendingTimeouts.add(timeoutId);\n\n            const cleanup = () => {\n                clearTimeout(timeoutId);\n                this.pendingTimeouts.delete(timeoutId);\n                this.off(ChannelEvents.SUBSCRIBED, handleSubscribed);\n                this.off(ChannelEvents.FAILED, handleFailed);\n            };\n\n            this.once(ChannelEvents.SUBSCRIBED, handleSubscribed);\n            this.once(ChannelEvents.FAILED, handleFailed);\n\n            try {\n                // If not queued, execute immediately\n                if (!willQueue) {\n                    this.executeSubscribe(callback, options);\n                }\n                // If queued, the operation will execute when processOperationQueue is called\n            } catch (error) {\n                cleanup();\n                reject(error);\n            }\n        });\n    }\n\n    /**\n     * Internal method that synchronously executes the subscribe operation.\n     * This is called either immediately or after processing the queue.\n     */\n    private executeSubscribe(\n        callback: (message: Message) => void,\n        options?: SubscribeOptions\n    ): void {\n        this.logger.debug(\n            `Executing subscribe for channel: ${this.name} (subscribed: ${this.subscribed}, event: ${options?.event})`\n        );\n\n        // Handle event-specific subscription\n        if (options?.event) {\n            // Get or create the set of callbacks for this event\n            let callbacks = this.eventCallbacks.get(options.event);\n            if (!callbacks) {\n                callbacks = new Set();\n                this.eventCallbacks.set(options.event, callbacks);\n            }\n\n            // Add the callback\n            callbacks.add(callback);\n\n            this.logger.info(\n                `Subscribed to event \"${options.event}\" on channel: ${this.name} (total callbacks for this event: ${callbacks.size})`\n            );\n\n            // If not already subscribed to channel, subscribe with master callback\n            if (!this.isSubscribed() && !this.pendingSubscribe) {\n                this.logger.debug(\n                    `Channel ${this.name} not subscribed - setting up event-driven subscription`\n                );\n                this.setupMessageHandler();\n                this.logger.info(\n                    `Subscribing to channel: ${this.name} (event-driven mode)`\n                );\n                this.emit(ChannelEvents.SUBSCRIBING, {\n                    channelName: this.name,\n                });\n\n                // Master callback distributes to event-specific callbacks\n                this.logger.debug(\n                    `Creating master callback for event routing on channel: ${this.name}`\n                );\n                this.messageCallback = (message: Message) => {\n                    if (message.event) {\n                        const eventCallbacks = this.eventCallbacks.get(\n                            message.event\n                        );\n                        if (eventCallbacks) {\n                            this.logger.trace(\n                                `Routing message to ${eventCallbacks.size} callback(s) for event \"${message.event}\" on channel: ${this.name}`\n                            );\n                            eventCallbacks.forEach((cb) => cb(message));\n                        }\n                    }\n                };\n                this.pendingSubscribe = true;\n\n                const actionMessage: OutgoingChannelMessage = {\n                    action: ActionType.SUBSCRIBE,\n                    channel: this.name,\n                };\n                this.logger.trace(\n                    `Sending subscribe message for channel ${this.name}:`,\n                    actionMessage\n                );\n                this.wsClient.send(JSON.stringify(actionMessage));\n            } else {\n                this.logger.debug(\n                    `Channel ${this.name} already subscribed or subscribing - event callback added without new subscription`\n                );\n            }\n            return;\n        }\n\n        // Handle catch-all subscription (no specific event)\n        if (this.isSubscribed() && !this.pendingSubscribe) {\n            // Channel is already subscribed, just update the callback\n            this.logger.info(\n                `Channel ${this.name} already subscribed - updating to catch-all callback`\n            );\n            this.messageCallback = callback;\n            // Clear event-specific callbacks when switching to catch-all\n            this.eventCallbacks.clear();\n            return;\n        }\n\n        // Ensure handler is attached to WebSocket (idempotent operation)\n        this.logger.debug(\n            `Setting up catch-all subscription for channel: ${this.name}`\n        );\n        this.setupMessageHandler();\n\n        this.logger.info(\n            `Subscribing to channel: ${this.name} (catch-all mode)`\n        );\n        this.emit(ChannelEvents.SUBSCRIBING, {\n            channelName: this.name,\n        });\n        this.messageCallback = callback;\n        // Clear event-specific callbacks when using catch-all\n        this.eventCallbacks.clear();\n        this.pendingSubscribe = true;\n\n        const actionMessage: OutgoingChannelMessage = {\n            action: ActionType.SUBSCRIBE,\n            channel: this.name,\n        };\n        this.logger.debug(\n            `Sending subscribe request to server for channel: ${this.name}`\n        );\n        this.logger.trace(\n            `Sending subscribe message for channel ${this.name}:`,\n            actionMessage\n        );\n        this.wsClient.send(JSON.stringify(actionMessage));\n    }\n\n    public async resubscribe(): Promise<void> {\n        this.logger.debug(\n            `Resubscribe requested for channel ${this.name} (has callback: ${!!this.messageCallback}, event callbacks: ${this.eventCallbacks.size})`\n        );\n\n        // Only resubscribe if we have a callback or event callbacks\n        if (!this.messageCallback && this.eventCallbacks.size === 0) {\n            this.logger.debug(\n                `Skipping resubscribe for channel ${this.name} - no callbacks registered`\n            );\n            return;\n        }\n\n        try {\n            this.logger.info(`Resubscribing to channel: ${this.name}`);\n            // Store the current callbacks before resubscribing\n            const existingCallback = this.messageCallback;\n            const existingEventCallbacks = new Map(this.eventCallbacks);\n\n            // Clear subscription state before resubscribing (important for reconnection scenarios)\n            // This ensures executeSubscribe will send a new SUBSCRIBE message\n            this.subscribed = false;\n            this.pendingSubscribe = false;\n            this.pendingUnsubscribe = false;\n\n            // If we have event-specific callbacks, resubscribe to each and wait for confirmation\n            if (existingEventCallbacks.size > 0) {\n                Array.from(existingEventCallbacks.entries()).forEach(\n                    ([event, callbacks]) => {\n                        Array.from(callbacks).forEach((callback) => {\n                            // Use executeSubscribe directly to bypass queueing\n                            this.executeSubscribe(callback, { event });\n                        });\n                    }\n                );\n                // Wait for the subscription to be confirmed (only one SUBSCRIBED event will fire)\n                await new Promise<void>((resolve, reject) => {\n                    const handleSubscribed = () => {\n                        this.off(ChannelEvents.SUBSCRIBED, handleSubscribed);\n                        this.off(ChannelEvents.FAILED, handleFailed);\n                        resolve();\n                    };\n                    const handleFailed = (event: any) => {\n                        this.off(ChannelEvents.SUBSCRIBED, handleSubscribed);\n                        this.off(ChannelEvents.FAILED, handleFailed);\n                        reject(event.error);\n                    };\n                    this.once(ChannelEvents.SUBSCRIBED, handleSubscribed);\n                    this.once(ChannelEvents.FAILED, handleFailed);\n                });\n            } else if (existingCallback) {\n                // Otherwise, resubscribe with the catch-all callback and wait\n                this.executeSubscribe(existingCallback);\n                // Wait for subscription confirmation\n                await new Promise<void>((resolve, reject) => {\n                    const handleSubscribed = () => {\n                        this.off(ChannelEvents.SUBSCRIBED, handleSubscribed);\n                        this.off(ChannelEvents.FAILED, handleFailed);\n                        resolve();\n                    };\n                    const handleFailed = (event: any) => {\n                        this.off(ChannelEvents.SUBSCRIBED, handleSubscribed);\n                        this.off(ChannelEvents.FAILED, handleFailed);\n                        reject(event.error);\n                    };\n                    this.once(ChannelEvents.SUBSCRIBED, handleSubscribed);\n                    this.once(ChannelEvents.FAILED, handleFailed);\n                });\n            }\n        } catch (error) {\n            this.logger.error(\n                `Resubscribe failed for channel ${this.name}:`,\n                error\n            );\n            this.emit(ChannelEvents.FAILED, {\n                channelName: this.name,\n                error:\n                    error instanceof Error ? error : new Error(\"Unknown error\"),\n                action: \"resubscribe\",\n            });\n            throw error;\n        }\n    }\n\n    /**\n     * Unsubscribe from channel. Returns a Promise that resolves when unsubscription is confirmed.\n     * Can be used with or without await:\n     * - Fire-and-forget: channel.unsubscribe()\n     * - Wait for confirmation: await channel.unsubscribe()\n     */\n    public async unsubscribe(\n        callback?: (message: Message) => void,\n        options?: SubscribeOptions & { timeout?: number }\n    ): Promise<void> {\n        const timeout = options?.timeout || 10000; // Default 10s timeout\n\n        this.logger.debug(\n            `Unsubscribe requested for channel: ${this.name} (subscribed: ${this.subscribed}, event: ${options?.event}, pendingSubscribe: ${this.pendingSubscribe}, pendingUnsubscribe: ${this.pendingUnsubscribe})`\n        );\n\n        // Determine if we need to wait for network confirmation\n        let needsNetworkConfirmation = false;\n        let willQueue = false;\n\n        // Special handling for event-specific unsubscriptions:\n        // They can proceed if the channel is subscribed because they just\n        // remove from the event callbacks map\n        if (options?.event) {\n            if (this.isSubscribed() && !this.pendingUnsubscribe) {\n                // Channel is subscribed and stable, can remove event callback immediately\n                // Check if this will trigger full unsubscribe\n                const callbacks = this.eventCallbacks.get(options.event);\n                if (callbacks) {\n                    const willBeEmpty = callback\n                        ? callbacks.size === 1 && callbacks.has(callback)\n                        : true;\n                    const isLastEvent = this.eventCallbacks.size === 1;\n                    needsNetworkConfirmation = willBeEmpty && isLastEvent;\n                }\n\n                if (!needsNetworkConfirmation) {\n                    this.executeUnsubscribe(callback, options);\n                    return Promise.resolve();\n                }\n            } else {\n                // Otherwise queue it\n                if (this.pendingSubscribe || this.pendingUnsubscribe) {\n                    this.logger.info(\n                        `Queueing event unsubscribe operation for channel ${this.name} (pendingSubscribe: ${this.pendingSubscribe}, pendingUnsubscribe: ${this.pendingUnsubscribe})`\n                    );\n                    this.operationQueue.push({\n                        type: \"unsubscribe\",\n                        callback,\n                        options,\n                    });\n                    willQueue = true;\n                    needsNetworkConfirmation = true;\n                } else {\n                    needsNetworkConfirmation = true;\n                }\n            }\n        } else {\n            // Full channel unsubscribe\n            if (!this.isSubscribed() && !this.pendingSubscribe) {\n                // Not subscribed, resolve immediately\n                return Promise.resolve();\n            }\n\n            if (this.pendingSubscribe || this.pendingUnsubscribe) {\n                this.logger.info(\n                    `Queueing unsubscribe operation for channel ${this.name} (pendingSubscribe: ${this.pendingSubscribe}, pendingUnsubscribe: ${this.pendingUnsubscribe})`\n                );\n                this.operationQueue.push({\n                    type: \"unsubscribe\",\n                    callback,\n                    options,\n                });\n                willQueue = true;\n                needsNetworkConfirmation = true;\n            } else {\n                needsNetworkConfirmation = true;\n            }\n        }\n\n        if (!needsNetworkConfirmation) {\n            this.executeUnsubscribe(callback, options);\n            return Promise.resolve();\n        }\n\n        // Need to wait for network confirmation\n        return new Promise<void>((resolve, reject) => {\n            const handleUnsubscribed = () => {\n                cleanup();\n                this.logger.debug(\n                    `Unsubscribe resolved for channel: ${this.name}`\n                );\n                resolve();\n            };\n\n            const handleFailed = (event: any) => {\n                cleanup();\n                this.logger.error(\n                    `Unsubscribe rejected for channel: ${this.name}`,\n                    event.error\n                );\n                reject(event.error);\n            };\n\n            const timeoutId = setTimeout(() => {\n                cleanup();\n                const error = new Error(\n                    `Unsubscription timeout after ${timeout}ms for channel: ${this.name}`\n                );\n                this.logger.error(error.message);\n                reject(error);\n            }, timeout);\n\n            // Track the timeout so it can be cleaned up\n            this.pendingTimeouts.add(timeoutId);\n\n            const cleanup = () => {\n                clearTimeout(timeoutId);\n                this.pendingTimeouts.delete(timeoutId);\n                this.off(ChannelEvents.UNSUBSCRIBED, handleUnsubscribed);\n                this.off(ChannelEvents.FAILED, handleFailed);\n            };\n\n            this.once(ChannelEvents.UNSUBSCRIBED, handleUnsubscribed);\n            this.once(ChannelEvents.FAILED, handleFailed);\n\n            try {\n                // If not queued, execute immediately\n                if (!willQueue) {\n                    this.executeUnsubscribe(callback, options);\n                }\n                // If queued, the operation will execute when processOperationQueue is called\n            } catch (error) {\n                cleanup();\n                reject(error);\n            }\n        });\n    }\n\n    /**\n     * Internal method that synchronously executes the unsubscribe operation.\n     * This is called either immediately or after processing the queue.\n     */\n    private executeUnsubscribe(\n        callback?: (message: Message) => void,\n        options?: SubscribeOptions\n    ): void {\n        // Handle event-specific unsubscribe\n        if (options?.event) {\n            this.logger.debug(\n                `Event-specific unsubscribe requested for event \"${options.event}\" on channel: ${this.name}`\n            );\n\n            const callbacks = this.eventCallbacks.get(options.event);\n            if (!callbacks) {\n                this.logger.debug(\n                    `No callbacks found for event \"${options.event}\" on channel: ${this.name}`\n                );\n                return;\n            }\n\n            if (callback) {\n                // Remove specific callback from specific event\n                callbacks.delete(callback);\n                if (callbacks.size === 0) {\n                    this.eventCallbacks.delete(options.event);\n                }\n                this.logger.info(\n                    `Unsubscribed callback from event \"${options.event}\" on channel: ${this.name} (remaining callbacks: ${callbacks.size})`\n                );\n            } else {\n                // Remove all callbacks for this event\n                this.eventCallbacks.delete(options.event);\n                this.logger.info(\n                    `Unsubscribed all callbacks from event \"${options.event}\" on channel: ${this.name}`\n                );\n            }\n\n            // If no more event callbacks, fully unsubscribe from channel\n            if (this.eventCallbacks.size === 0 && this.isSubscribed()) {\n                this.logger.info(\n                    `No more event callbacks - fully unsubscribing from channel: ${this.name}`\n                );\n                // Continue to full unsubscribe logic below\n            } else {\n                this.logger.debug(\n                    `Still have ${this.eventCallbacks.size} event(s) with callbacks - keeping channel subscription`\n                );\n                return; // Still have event callbacks, don't unsubscribe from channel\n            }\n        }\n\n        // Handle full unsubscribe from channel\n        this.logger.debug(\n            `Full unsubscribe requested for channel ${this.name} (subscribed: ${this.subscribed})`\n        );\n\n        if (!this.isSubscribed()) {\n            this.logger.debug(\n                `Channel ${this.name} not subscribed - skipping unsubscribe`\n            );\n            return;\n        }\n\n        // If WebSocket is not connected, don't send unsubscribe but keep callback for auto-resubscribe\n        if (!this.wsClient.isConnected()) {\n            this.logger.warn(\n                `WebSocket not connected - clearing subscription flag but keeping callback for auto-resubscribe`\n            );\n            this.subscribed = false;\n            // Don't clear messageCallback - preserve it for auto-resubscribe on reconnection\n            this.emit(ChannelEvents.UNSUBSCRIBED, {\n                channelName: this.name,\n            });\n            return;\n        }\n\n        this.logger.info(`Unsubscribing from channel: ${this.name}`);\n        this.emit(ChannelEvents.UNSUBSCRIBING, {\n            channelName: this.name,\n        });\n        this.pendingUnsubscribe = true;\n\n        const actionMessage: OutgoingChannelMessage = {\n            action: ActionType.UNSUBSCRIBE,\n            channel: this.name,\n        };\n        this.logger.debug(\n            `Sending unsubscribe request to server for channel: ${this.name}`\n        );\n        this.logger.trace(\n            `Sending unsubscribe message for channel ${this.name}:`,\n            actionMessage\n        );\n        this.wsClient.send(JSON.stringify(actionMessage));\n    }\n\n    public isSubscribed(): boolean {\n        return this.subscribed;\n    }\n\n    public isPendingSubscribe(): boolean {\n        return this.pendingSubscribe;\n    }\n\n    public setPendingSubscribe(pending: boolean): void {\n        this.logger.debug(\n            `Setting pendingSubscribe to ${pending} for channel: ${this.name}`\n        );\n        this.pendingSubscribe = pending;\n    }\n\n    public pause(options?: { bufferMessages?: boolean }): void {\n        if (this.paused) {\n            this.logger.debug(\n                `Channel ${this.name} is already paused - ignoring pause request`\n            );\n            return;\n        }\n\n        this.paused = true;\n\n        // Update buffer setting if provided\n        if (options?.bufferMessages !== undefined) {\n            this.bufferWhilePaused = options.bufferMessages;\n        }\n\n        this.logger.info(\n            `Channel ${this.name} paused (buffering: ${this.bufferWhilePaused})`\n        );\n        this.emit(ChannelEvents.PAUSED, {\n            channelName: this.name,\n            buffering: this.bufferWhilePaused,\n        });\n    }\n\n    public resume(): void {\n        if (!this.paused) {\n            this.logger.debug(\n                `Channel ${this.name} is not paused - ignoring resume request`\n            );\n            return;\n        }\n\n        this.paused = false;\n\n        // Deliver buffered messages if any\n        const bufferedCount = this.pausedMessages.length;\n        if (bufferedCount > 0) {\n            this.logger.info(\n                `Channel ${this.name} resumed - delivering ${bufferedCount} buffered message(s)`\n            );\n            this.pausedMessages.forEach((message) => {\n                this.messageCallback?.(message);\n            });\n            this.pausedMessages = [];\n        } else {\n            this.logger.info(`Channel ${this.name} resumed`);\n        }\n\n        this.emit(ChannelEvents.RESUMED, {\n            channelName: this.name,\n            bufferedMessagesDelivered: bufferedCount,\n        });\n    }\n\n    public isPaused(): boolean {\n        return this.paused;\n    }\n\n    public hasCallback(): boolean {\n        return !!this.messageCallback;\n    }\n\n    public clearBufferedMessages(): void {\n        const count = this.pausedMessages.length;\n        if (count > 0) {\n            this.logger.info(\n                `Clearing ${count} buffered message(s) for channel: ${this.name}`\n            );\n            this.pausedMessages = [];\n        }\n    }\n\n    public reset(): void {\n        this.logger.info(`Resetting channel: ${this.name}`);\n\n        // Remove the handler from the WebSocket, but don't destroy the function\n        const socket = this.wsClient.getSocket();\n        if (socket) {\n            this.logger.debug(\n                `Removing message handler for channel: ${this.name}`\n            );\n            socket.removeEventListener(\"message\", this.messageHandler);\n        }\n\n        // Only attempt to unsubscribe if WebSocket is still connected\n        // If disconnected, the server will handle cleanup automatically\n        if (this.isSubscribed() && this.wsClient.isConnected()) {\n            try {\n                this.logger.debug(\n                    `Unsubscribing channel ${this.name} during reset`\n                );\n                this.unsubscribe();\n            } catch (error) {\n                // Log error but don't throw to prevent blocking reset\n                this.logger.warn(\n                    `Failed to unsubscribe from channel ${this.name} during reset:`,\n                    error\n                );\n            }\n        }\n\n        // Reset local state regardless of unsubscribe success\n        this.logger.debug(`Clearing local state for channel: ${this.name}`);\n\n        // Clear all pending timeouts to prevent memory leaks and hanging promises\n        this.pendingTimeouts.forEach((timeoutId) => {\n            clearTimeout(timeoutId);\n        });\n        this.pendingTimeouts.clear();\n\n        this.subscribed = false;\n        this.messageCallback = undefined;\n        this.eventCallbacks.clear();\n        this.pendingSubscribe = false;\n        this.pendingUnsubscribe = false;\n        this.operationQueue = [];\n        this.paused = false;\n        this.pausedMessages = [];\n        this.removeAllListeners();\n        this.logger.info(`Channel ${this.name} reset complete`);\n    }\n}\n","import { BaseChannel } from \"./channel\";\nimport {\n    IHttpClient,\n    ILogger,\n} from \"../../types/services/clients\";\nimport {\n    IAuthManager,\n    IOptionManager,\n} from \"../../types/services/managers\";\nimport { RestPublishRequest } from \"../../types/protocol/messages\";\nimport { ChannelEvents } from \"../../types/events/constants\";\nimport { PublishOptions } from \"../../types/services/channel\";\n\nexport class RestChannel extends BaseChannel {\n    private httpClient: IHttpClient;\n    private authManager: IAuthManager;\n    private optionManager: IOptionManager;\n    private logger: ILogger;\n\n    constructor(\n        name: string,\n        httpClient: IHttpClient,\n        authManager: IAuthManager,\n        optionManager: IOptionManager,\n        logger: ILogger\n    ) {\n        super(name);\n        this.httpClient = httpClient;\n        this.authManager = authManager;\n        this.optionManager = optionManager;\n        this.logger = logger;\n        this.logger.debug(`RestChannel created for: ${name}`);\n    }\n\n    public async publish<T = any>(\n        data: any,\n        options?: PublishOptions\n    ): Promise<T> {\n        this.logger.debug(\n            `Publishing to REST channel ${this.name}${options?.event ? ` (event: ${options.event})` : \"\"}${options?.alias ? ` (alias: ${options.alias})` : \"\"}`\n        );\n\n        try {\n            const headers = this.authManager.getAuthHeaders();\n            const host = this.optionManager.getOption(\"httpHost\");\n            const port = this.optionManager.getOption(\"httpPort\");\n            const isSecure = this.optionManager.getOption(\"isSecure\");\n            const protocol = isSecure ? \"https\" : \"http\";\n            const url = `${protocol}://${host}${\n                port ? `:${port}` : \"\"\n            }/v1/channel/${this.name}/messages`;\n\n            const requestPayload: RestPublishRequest = {\n                messages: [\n                    {\n                        alias: options?.alias,\n                        event: options?.event,\n                        data,\n                    },\n                ],\n            };\n\n            this.logger.trace(\n                `Sending REST publish to ${url} for channel ${this.name}:`,\n                requestPayload\n            );\n\n            const result = await this.httpClient.post<T>(\n                url,\n                requestPayload,\n                headers\n            );\n\n            this.logger.info(`Published message to REST channel: ${this.name}`);\n\n            return result;\n        } catch (error) {\n            this.logger.error(\n                `Error publishing to REST channel ${this.name}:`,\n                error\n            );\n            this.emit(ChannelEvents.FAILED, {\n                channelName: this.name,\n                error:\n                    error instanceof Error ? error : new Error(\"Unknown error\"),\n                action: \"publish\",\n            });\n            throw error;\n        }\n    }\n\n    public reset(): void {\n        this.logger.info(`Resetting REST channel: ${this.name}`);\n        this.removeAllListeners();\n        this.logger.debug(`REST channel ${this.name} reset complete`);\n    }\n}\n","import { ChannelManager } from \"../../types/services/channel\";\nimport { SocketChannel } from \"../channels/socket-channel\";\nimport { RestChannel } from \"../channels/rest-channel\";\nimport {\n    IWebSocketClient,\n    ILogger,\n    IHttpClient,\n} from \"../../types/services/clients\";\nimport {\n    ISocketChannelManager,\n    IAuthManager,\n    IOptionManager,\n} from \"../../types/services/managers\";\nimport {\n    DataMessagePayload,\n    RestPublishRequest,\n} from \"../../types/protocol/messages\";\n\nexport class SocketChannelManager\n    implements ChannelManager, ISocketChannelManager\n{\n    private channels: Map<string, SocketChannel> = new Map();\n    private channelRefCounts: Map<string, number> = new Map();\n    private wsClient: IWebSocketClient;\n    private logger: ILogger;\n\n    constructor(wsClient: IWebSocketClient, logger: ILogger) {\n        this.wsClient = wsClient;\n        this.logger = logger;\n    }\n\n    public get(channelName: string): SocketChannel {\n        const isNewChannel = !this.channels.has(channelName);\n\n        if (isNewChannel) {\n            this.logger.debug(`Creating new socket channel: ${channelName}`);\n            this.channels.set(\n                channelName,\n                new SocketChannel(channelName, this.wsClient, this.logger)\n            );\n        }\n\n        // Increment reference count\n        const currentCount = this.channelRefCounts.get(channelName) || 0;\n        this.channelRefCounts.set(channelName, currentCount + 1);\n\n        if (!isNewChannel && currentCount === 0) {\n            // Channel existed with ref count 0 (was kept for auto-resubscribe)\n            this.logger.debug(\n                `Channel ${channelName} re-acquired (was kept for auto-resubscribe, ref count: 1)`\n            );\n        } else {\n            this.logger.debug(\n                `Channel ${channelName} reference count: ${currentCount + 1}`\n            );\n        }\n\n        return this.channels.get(channelName)!;\n    }\n\n    /**\n     * Release a reference to a channel. When the reference count reaches 0:\n     * - If the channel has a callback (was subscribed), keep it for auto-resubscribe\n     * - If the channel has no callback (was never subscribed), remove it completely\n     *\n     * @param channelName - The name of the channel to release\n     */\n    public release(channelName: string): void {\n        const count = this.channelRefCounts.get(channelName);\n\n        if (count === undefined || count < 0) {\n            this.logger.warn(\n                `Attempted to release channel ${channelName} with no active references`\n            );\n            return;\n        }\n\n        if (count === 0) {\n            // Channel exists with ref count 0 (kept for auto-resubscribe)\n            // This shouldn't happen in normal use, but handle it gracefully\n            this.logger.debug(\n                `Attempted to release channel ${channelName} that has ref count 0 (kept for auto-resubscribe)`\n            );\n            return;\n        }\n\n        if (count === 1) {\n            // Last reference - check if we should keep the channel for auto-resubscribe\n            const channel = this.channels.get(channelName);\n\n            if (channel && channel.hasCallback()) {\n                // Channel was subscribed - keep it in manager for auto-resubscribe\n                // Just decrement ref count to 0, don't remove\n                this.channelRefCounts.set(channelName, 0);\n                this.logger.debug(\n                    `Last reference to channel ${channelName} released - keeping for auto-resubscribe (ref count: 0)`\n                );\n            } else {\n                // Channel was never subscribed - clean up completely\n                this.logger.debug(\n                    `Last reference to channel ${channelName} released - cleaning up`\n                );\n                if (channel) {\n                    // Call reset() which properly cleans up WebSocket handlers\n                    try {\n                        channel.reset();\n                    } catch (error) {\n                        this.logger.warn(\n                            `Failed to reset channel ${channelName} during cleanup:`,\n                            error\n                        );\n                    }\n                    // Remove the channel from the manager\n                    this.channels.delete(channelName);\n                    this.logger.debug(\n                        `Channel ${channelName} removed from manager`\n                    );\n                }\n                this.channelRefCounts.delete(channelName);\n            }\n        } else {\n            // Still have other references\n            this.channelRefCounts.set(channelName, count - 1);\n            this.logger.debug(\n                `Channel ${channelName} reference count: ${count - 1}`\n            );\n        }\n    }\n\n    public getAllChannels(): SocketChannel[] {\n        return Array.from(this.channels.values());\n    }\n\n    public has(channelName: string): boolean {\n        return this.channels.has(channelName);\n    }\n\n    public remove(channelName: string): void {\n        const channel = this.channels.get(channelName);\n        if (channel) {\n            // Clean up the channel before removing\n            channel.removeAllListeners();\n            this.channels.delete(channelName);\n            this.logger.debug(`Channel ${channelName} removed`);\n        }\n    }\n\n    public pendingSubscribeAllChannels(): void {\n        const channels = this.getAllChannels();\n        for (const channel of channels) {\n            channel.setPendingSubscribe(true);\n        }\n    }\n\n    public async resubscribeAllChannels(): Promise<void> {\n        const allChannels = this.getAllChannels();\n        // Only attempt to resubscribe channels that have a callback (were previously subscribed)\n        const channelsToResubscribe = allChannels.filter((channel) =>\n            channel.hasCallback()\n        );\n\n        if (channelsToResubscribe.length === 0) {\n            this.logger.debug(\n                `No channels with active subscriptions to resubscribe`\n            );\n            return;\n        }\n\n        this.logger.debug(\n            `Resubscribing to ${channelsToResubscribe.length} channel(s)`\n        );\n\n        for (const channel of channelsToResubscribe) {\n            try {\n                await channel.resubscribe();\n                this.logger.debug(\n                    `Resubscribed to channel: ${channel.getName()}`\n                );\n            } catch (error) {\n                this.logger.error(\n                    `Failed to resubscribe to channel ${channel.getName()}:`,\n                    error\n                );\n            }\n        }\n    }\n\n    public reset(): void {\n        this.logger.debug(\"Resetting all socket channels\");\n        // Reset all channels\n        this.channels.forEach((channel) => channel.reset());\n        this.channels.clear();\n        this.channelRefCounts.clear();\n    }\n}\n\nexport class RestChannelManager implements ChannelManager {\n    private channels: Map<string, RestChannel> = new Map();\n    private httpClient: IHttpClient;\n    private authManager: IAuthManager;\n    private optionManager: IOptionManager;\n    private logger: ILogger;\n\n    constructor(\n        httpClient: IHttpClient,\n        authManager: IAuthManager,\n        optionManager: IOptionManager,\n        logger: ILogger\n    ) {\n        this.httpClient = httpClient;\n        this.authManager = authManager;\n        this.optionManager = optionManager;\n        this.logger = logger;\n    }\n\n    public get(channelName: string): RestChannel {\n        if (!this.channels.has(channelName)) {\n            this.logger.debug(`Creating new REST channel: ${channelName}`);\n            this.channels.set(\n                channelName,\n                new RestChannel(\n                    channelName,\n                    this.httpClient,\n                    this.authManager,\n                    this.optionManager,\n                    this.logger\n                )\n            );\n        }\n\n        return this.channels.get(channelName)!;\n    }\n\n    public async publishBatch<T = any>(\n        channels: string[],\n        messages: DataMessagePayload[]\n    ): Promise<T> {\n        const headers = this.authManager.getAuthHeaders();\n        const host = this.optionManager.getOption(\"httpHost\");\n        const port = this.optionManager.getOption(\"httpPort\");\n        const isSecure = this.optionManager.getOption(\"isSecure\");\n        const protocol = isSecure ? \"https\" : \"http\";\n        const url = `${protocol}://${host}${\n            port ? `:${port}` : \"\"\n        }/v1/channels/messages`;\n\n        const requestPayload: RestPublishRequest = {\n            channels,\n            messages,\n        };\n\n        this.logger.debug(`Publishing batch to ${url}`);\n        this.logger.debug(`Request payload: ${JSON.stringify(requestPayload)}`);\n        this.logger.debug(`Headers: ${JSON.stringify(headers)}`);\n\n        return await this.httpClient.post<T>(url, requestPayload, headers);\n    }\n\n    public has(channelName: string): boolean {\n        return this.channels.has(channelName);\n    }\n\n    public remove(channelName: string): void {\n        const channel = this.channels.get(channelName);\n        if (channel) {\n            // Clean up the channel before removing\n            channel.removeAllListeners();\n            this.channels.delete(channelName);\n            this.logger.debug(`REST channel ${channelName} removed`);\n        }\n    }\n\n    public reset(): void {\n        this.logger.debug(\"Resetting all REST channels\");\n        // Reset all channels\n        this.channels.forEach((channel) => channel.reset());\n        this.channels.clear();\n    }\n}\n","import { AuthEvents, ConnectionEvents } from \"../../types/events/constants\";\nimport { EventEmitter } from \"../shared/event-emitter\";\nimport { ConnectionEventPayloads } from \"../../types/events/payloads\";\nimport { QPubWebSocket } from \"../../types/services/websocket\";\nimport {\n    IncomingConnectionMessage,\n    IncomingMessage, PingMessage,\n    PongMessage\n} from \"../../types/protocol/messages\";\nimport { ActionType } from \"../../types/protocol/actions\";\nimport {\n    IOptionManager,\n    IAuthManager,\n    ISocketChannelManager,\n} from \"../../types/services/managers\";\nimport {\n    IWebSocketClient,\n    ILogger,\n} from \"../../types/services/clients\";\nimport { IConnection } from \"../../types/services/connection\";\n\nexport class Connection\n    extends EventEmitter<ConnectionEventPayloads>\n    implements IConnection\n{\n    private optionManager: IOptionManager;\n    private authManager: IAuthManager;\n    private wsClient: IWebSocketClient;\n    private channelManager: ISocketChannelManager;\n    private logger: ILogger;\n    private socket: QPubWebSocket | null = null;\n    private reconnectAttempts: number = 0;\n    private reconnectTimeout?: NodeJS.Timeout;\n    private isReconnecting: boolean = false;\n    private isIntentionalDisconnect: boolean = false;\n    private _isResetting: boolean = false; // Add reset flag\n    private pingTimeout?: NodeJS.Timeout;\n    private pendingPings: Map<string, { startTime: number; resolve: (rtt: number) => void; reject: (error: Error) => void; timeout?: NodeJS.Timeout }> = new Map();\n    private pingCounter: number = 0; // Sequential counter for unique ping IDs\n\n    constructor(\n        optionManager: IOptionManager,\n        authManager: IAuthManager,\n        wsClient: IWebSocketClient,\n        channelManager: ISocketChannelManager,\n        logger: ILogger\n    ) {\n        super();\n        this.optionManager = optionManager;\n        this.authManager = authManager;\n        this.wsClient = wsClient;\n        this.channelManager = channelManager;\n        this.logger = logger;\n\n        this.setupAuthListeners();\n        this.logger.info(\"Connection instance initialized\");\n        this.emit(ConnectionEvents.INITIALIZED);\n    }\n\n    private getAuthenticatedWsUrl(): string {\n        const secure = this.optionManager.getOption(\"isSecure\");\n        const host = this.optionManager.getOption(\"wsHost\");\n        const port = this.optionManager.getOption(\"wsPort\");\n\n        const protocol = secure ? \"wss\" : \"ws\";\n        const baseUrl = `${protocol}://${host}${port ? `:${port}` : \"\"}/v1`;\n\n        return this.authManager.getAuthenticateUrl(baseUrl);\n    }\n\n    public async connect(): Promise<void> {\n        // Prevent connection attempts during reset\n        if (this._isResetting) {\n            this.logger.debug(\"Connection attempt blocked - connection is resetting\");\n            return;\n        }\n\n        try {\n            this.emit(ConnectionEvents.CONNECTING, { attempt: 1 });\n\n            if (this.authManager.shouldAutoAuthenticate()) {\n                await this.authManager.authenticate();\n            }\n\n            const wsUrl = this.getAuthenticatedWsUrl();\n            this.wsClient.connect(wsUrl);\n\n            this.socket = this.wsClient.getSocket();\n            if (this.socket) {\n                this.setupSocketListeners();\n            }\n        } catch (error) {\n            this.handleAuthError(error as Error);\n        }\n    }\n\n    public isConnected(): boolean {\n        return this.wsClient.isConnected();\n    }\n\n    public isResetting(): boolean {\n        return this._isResetting;\n    }\n\n    public ping(): Promise<number> {\n        return new Promise((resolve, reject) => {\n            if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {\n                reject(new Error(\"WebSocket is not connected\"));\n                return;\n            }\n\n            // Generate unique ping ID\n            const pingId = ++this.pingCounter;\n            const startTime = performance.now();\n\n            // Store the pending ping with its resolve/reject callbacks\n            this.pendingPings.set(pingId.toString(), { startTime, resolve, reject });\n\n            // Set a timeout for this specific ping\n            const timeout = setTimeout(() => {\n                this.pendingPings.delete(pingId.toString());\n                reject(new Error(\"Ping timeout\"));\n            }, this.optionManager.getOption(\"pingTimeoutMs\") || 10000);\n\n            // Store timeout ID to clear it when pong is received\n            this.pendingPings.get(pingId.toString())!.timeout = timeout;\n\n            // Create ping message\n            const pingMessage: PingMessage = {\n                action: ActionType.PING,\n                timestamp: pingId\n            };\n\n            try {\n                this.socket.send(JSON.stringify(pingMessage));\n                this.logger.debug(`Sent ping with ID: ${pingId}`);\n            } catch (error) {\n                clearTimeout(timeout);\n                this.pendingPings.delete(pingId.toString());\n                reject(error instanceof Error ? error : new Error(String(error)));\n            }\n        });\n    }\n\n    private setupSocketListeners(): void {\n        if (!this.socket) return;\n\n        this.socket.onopen = () => {\n            this.logger.info(\"WebSocket connection opened\");\n            this.reconnectAttempts = 0;\n            this.isReconnecting = false;\n            this.isIntentionalDisconnect = false;\n            this.emit(ConnectionEvents.OPENED, {});\n            this.setupPingHandler();\n\n            if (this.optionManager.getOption(\"autoResubscribe\")) {\n                this.channelManager.resubscribeAllChannels();\n            }\n        };\n\n        this.socket.onclose = (event: CloseEvent) => {\n            this.logger.info(\n                `WebSocket connection closed: ${event.code} ${event.reason}`\n            );\n            if (this.pingTimeout) {\n                clearTimeout(this.pingTimeout);\n                this.pingTimeout = undefined;\n            }\n\n\n            this.emit(ConnectionEvents.CLOSED, {\n                code: event.code,\n                reason: event.reason,\n                wasClean: event.wasClean,\n            });\n\n            this.channelManager.pendingSubscribeAllChannels();\n\n            // Only attempt reconnection if it wasn't an intentional close\n            if (\n                !this.isReconnecting &&\n                !this.isIntentionalDisconnect &&\n                this.optionManager.getOption(\"autoReconnect\")\n            ) {\n                this.handleConnectionClosed();\n            }\n        };\n\n        this.socket.onerror = (event: Event) => {\n            this.logger.error(\"WebSocket connection error:\", event);\n            this.channelManager.pendingSubscribeAllChannels();\n            this.emit(ConnectionEvents.FAILED, {\n                error: new Error(\"WebSocket connection error\"),\n                context: \"websocket\",\n            });\n        };\n\n        this.socket.onmessage = (event: MessageEvent) => {\n            try {\n                const message: IncomingMessage = JSON.parse(event.data);\n                this.logger.debug(\"Received message:\", message);\n                if (message.action === ActionType.CONNECTED) {\n                    const connMessage = message as IncomingConnectionMessage;\n                    this.emit(ConnectionEvents.CONNECTED, {\n                        connectionId: connMessage.connection_id,\n                        connectionDetails: connMessage.connection_details,\n                    });\n                } else if (message.action === ActionType.DISCONNECTED) {\n                    this.emit(ConnectionEvents.DISCONNECTED, {});\n                } else if (message.action === ActionType.PONG) {\n                    // Handle pong response for ping() method\n                    this.handlePongResponse(message);\n                }\n            } catch (error) {\n                this.logger.error(\"Error processing message:\", error);\n                this.emit(ConnectionEvents.FAILED, {\n                    error:\n                        error instanceof Error\n                            ? error\n                            : new Error(\"Unknown error\"),\n                    context: \"message_processing\",\n                });\n            }\n        };\n\n        this.logger.debug(\"Socket listeners configured\");\n    }\n\n    private setupAuthListeners(): void {\n        this.authManager.on(\n            AuthEvents.TOKEN_EXPIRED,\n            this.handleTokenExpired.bind(this)\n        );\n        this.authManager.on(\n            AuthEvents.TOKEN_ERROR,\n            this.handleAuthError.bind(this)\n        );\n        this.authManager.on(\n            AuthEvents.AUTH_ERROR,\n            this.handleAuthError.bind(this)\n        );\n        this.logger.debug(\"Auth listeners configured\");\n    }\n\n    private setupPingHandler(): void {\n        if (!this.socket) return;\n\n        const PING_TIMEOUT =\n            this.optionManager.getOption(\"pingTimeoutMs\") || 60000;\n\n        // Note: Browser WebSocket API doesn't expose onping/onpong events\n        // These handlers only work in Node.js environments\n        \n        this.socket.onping = () => {\n            this.logger.debug(\"Ping received from server (Node.js only)\");\n            \n            if (this.pingTimeout) clearTimeout(this.pingTimeout);\n\n            this.pingTimeout = setTimeout(() => {\n                this.handleConnectionInterrupted();\n            }, PING_TIMEOUT);\n        };\n\n        this.socket.onpong = () => {\n            this.logger.debug(\"Pong received from server (Node.js only)\");\n        };\n\n        this.logger.debug(\"Ping handler configured\");\n    }\n\n    private handlePongResponse(message: IncomingMessage): void {\n        const pongMessage = message as PongMessage;\n        const pingId = pongMessage.timestamp?.toString();\n        \n        if (!pingId) {\n            this.logger.debug(\"Received pong without ping ID, ignoring\");\n            return;\n        }\n\n        const pendingPing = this.pendingPings.get(pingId);\n        if (!pendingPing) {\n            this.logger.debug(`Received pong for unknown ping ID: ${pingId}`);\n            return;\n        }\n\n        // Calculate RTT and resolve the promise\n        const rtt = performance.now() - pendingPing.startTime;\n        \n        // Clear the timeout\n        if (pendingPing.timeout) {\n            clearTimeout(pendingPing.timeout);\n        }\n        \n        this.pendingPings.delete(pingId);\n        \n        this.logger.debug(`Ping ${pingId} completed with RTT: ${rtt.toFixed(2)}ms`);\n        pendingPing.resolve(rtt);\n    }\n\n    private handleConnectionInterrupted(): void {\n        this.logger.warn(\n            \"Connection interrupted - no ping received within timeout period\"\n        );\n        if (this.pingTimeout) {\n            clearTimeout(this.pingTimeout);\n            this.pingTimeout = undefined;\n        }\n        this.disconnect();\n        this.handleConnectionClosed();\n    }\n\n    private async handleConnectionClosed() {\n        if (this.socket?.readyState === WebSocket.CLOSING) {\n            this.logger.debug(\n                \"Connection close handled - socket already closing\"\n            );\n            return;\n        }\n\n        if (\n            this.reconnectAttempts >=\n            this.optionManager.getOption(\"maxReconnectAttempts\")!\n        ) {\n            this.logger.debug(\n                \"Max reconnection attempts reached - not attempting reconnection\"\n            );\n            return;\n        }\n\n        if (this.optionManager.getOption(\"autoReconnect\")) {\n            this.logger.info(\"Initiating automatic reconnection\");\n            await this.attemptReconnection();\n        }\n    }\n\n    private async handleTokenExpired() {\n        await this.connect();\n    }\n\n    private handleAuthError(error: Error) {\n        this.emit(ConnectionEvents.FAILED, {\n            error,\n            context: \"authentication\",\n        });\n        this.disconnect();\n    }\n\n    private calculateReconnectDelay(): number {\n        const initial = this.optionManager.getOption(\n            \"initialReconnectDelayMs\"\n        )!;\n        const max = this.optionManager.getOption(\"maxReconnectDelayMs\")!;\n        const multiplier = this.optionManager.getOption(\n            \"reconnectBackoffMultiplier\"\n        )!;\n\n        const delay = initial * Math.pow(multiplier, this.reconnectAttempts);\n        return Math.min(delay, max);\n    }\n\n    private async attemptReconnection() {\n        if (this.isReconnecting) {\n            this.logger.debug(\"Reconnection already in progress\");\n            return;\n        }\n\n        const maxAttempts = this.optionManager.getOption(\n            \"maxReconnectAttempts\"\n        )!;\n        this.isReconnecting = true;\n        this.logger.info(\n            `Starting reconnection attempts (max: ${maxAttempts})`\n        );\n\n        while (this.reconnectAttempts < maxAttempts) {\n            try {\n                const delay = this.calculateReconnectDelay();\n                this.logger.debug(\n                    `Reconnection attempt ${\n                        this.reconnectAttempts + 1\n                    }/${maxAttempts} after ${delay}ms`\n                );\n\n                this.emit(ConnectionEvents.CONNECTING, {\n                    attempt: this.reconnectAttempts + 1,\n                });\n\n                await new Promise((resolve) => setTimeout(resolve, delay));\n\n                // Create a promise that will resolve/reject based on the next connection attempt\n                const connectionPromise = new Promise((resolve, reject) => {\n                    let timeoutId: NodeJS.Timeout;\n                    let isHandled = false;\n\n                    // Connection timeout handler\n                    const connectionTimeout = () => {\n                        if (!isHandled) {\n                            isHandled = true;\n                            reject(new Error(\"Connection attempt timed out\"));\n                        }\n                    };\n\n                    // Set a timeout for the connection attempt\n                    timeoutId = setTimeout(\n                        connectionTimeout,\n                        this.optionManager.getOption(\"connectTimeoutMs\") ||\n                            10000\n                    );\n\n                    this.connect()\n                        .then(() => {\n                            if (!isHandled) {\n                                isHandled = true;\n                                clearTimeout(timeoutId);\n                                // Wait a brief moment to ensure the socket is properly established\n                                setTimeout(() => {\n                                    if (\n                                        this.socket?.readyState ===\n                                        WebSocket.OPEN\n                                    ) {\n                                        resolve(true);\n                                    } else {\n                                        reject(\n                                            new Error(\n                                                \"WebSocket connection failed\"\n                                            )\n                                        );\n                                    }\n                                }, 100);\n                            }\n                        })\n                        .catch((error) => {\n                            if (!isHandled) {\n                                isHandled = true;\n                                clearTimeout(timeoutId);\n                                reject(error);\n                            }\n                        });\n                });\n\n                await connectionPromise;\n                return; // Successfully connected\n            } catch (error) {\n                this.reconnectAttempts++;\n                this.logger.warn(`Reconnection attempt failed: ${error}`);\n\n                if (this.reconnectAttempts >= maxAttempts) {\n                    this.logger.error(\"Max reconnection attempts reached\");\n                    this.emit(ConnectionEvents.FAILED, {\n                        error:\n                            error instanceof Error\n                                ? error\n                                : new Error(String(error)),\n                        context: \"reconnection\",\n                    });\n                    this.isReconnecting = false;\n                    break;\n                }\n            }\n        }\n    }\n\n    public disconnect(): void {\n        this.isReconnecting = false; // Prevent reconnection attempts\n        this.isIntentionalDisconnect = true; // Mark as intentional disconnect\n        if (this.pingTimeout) {\n            clearTimeout(this.pingTimeout);\n            this.pingTimeout = undefined;\n        }\n        if (this.reconnectTimeout) {\n            clearTimeout(this.reconnectTimeout);\n        }\n        // Reject all pending pings\n        this.pendingPings.forEach((pendingPing, pingId) => {\n            if (pendingPing.timeout) {\n                clearTimeout(pendingPing.timeout);\n            }\n            pendingPing.reject(new Error(\"Connection closed\"));\n        });\n        this.pendingPings.clear();\n        \n        this.emit(ConnectionEvents.CLOSING, {});\n        this.wsClient.disconnect();\n        this.emit(ConnectionEvents.CLOSED, {});\n    }\n\n    public reset(): void {\n        this.logger.info(\"Resetting Connection instance\");\n        \n        // 1. Set reset flag to prevent new operations\n        this._isResetting = true;\n        \n        // 2. Stop all pending operations\n        this.stopAllPendingOperations();\n        \n        // 3. Clean up timers\n        this.cleanupTimers();\n        \n        // 4. Disconnect WebSocket\n        this.emit(ConnectionEvents.CLOSING, {});\n        this.wsClient.disconnect();\n        this.emit(ConnectionEvents.CLOSED, {});\n        \n        // 5. Reset state\n        this.resetState();\n        \n        // 6. Remove all listeners\n        this.removeAllListeners();\n        \n        this.logger.info(\"Connection reset completed\");\n    }\n\n    private stopAllPendingOperations(): void {\n        // Stop reconnection attempts\n        this.isReconnecting = false;\n        \n        // Reject all pending pings with reset-specific error\n        this.pendingPings.forEach((pendingPing, pingId) => {\n            if (pendingPing.timeout) {\n                clearTimeout(pendingPing.timeout);\n            }\n            pendingPing.reject(new Error(\"Connection reset\"));\n        });\n        this.pendingPings.clear();\n    }\n\n    private cleanupTimers(): void {\n        if (this.pingTimeout) {\n            clearTimeout(this.pingTimeout);\n            this.pingTimeout = undefined;\n        }\n        if (this.reconnectTimeout) {\n            clearTimeout(this.reconnectTimeout);\n        }\n    }\n\n    private resetState(): void {\n        this.reconnectAttempts = 0;\n        this.isIntentionalDisconnect = false;\n        this._isResetting = false; // Reset the flag\n        this.socket = null;\n        \n        this.wsClient.reset();\n    }\n}\n","import { ServiceContainer } from \"./container\";\nimport { Option } from \"../../types/config/options\";\n\n// Core Service Implementations\nimport { OptionManager } from \"../managers/option-manager\";\nimport { HttpClient } from \"../transport/http-client\";\nimport { Logger } from \"../shared/logger\";\nimport { AuthManager } from \"../managers/auth-manager\";\nimport { WebSocketClient } from \"../connections/websocket-client\";\nimport { SocketChannelManager, RestChannelManager } from \"../managers/channel-manager\";\nimport { Connection } from \"../connections/connection\";\n\n// Service Interfaces\nimport {\n    IOptionManager,\n    IAuthManager,\n    ISocketChannelManager,\n} from \"../../types/services/managers\";\nimport {\n    IHttpClient,\n    ILogger,\n    ILoggerFactory,\n    IWebSocketClient,\n} from \"../../types/services/clients\";\nimport { IConnection } from \"../../types/services/connection\";\n\n/**\n * Logger factory implementation for creating component-specific loggers\n */\nclass LoggerFactory implements ILoggerFactory {\n    constructor(\n        private instanceId: string,\n        private optionManager: IOptionManager\n    ) {}\n\n    createLogger(component: string): ILogger {\n        return new Logger(this.instanceId, component, this.optionManager);\n    }\n}\n\n/**\n * Register all services for Socket-based instances\n */\nexport function registerSocketServices(\n    container: ServiceContainer,\n    instanceId: string,\n    options: Partial<Option> = {}\n): void {\n    // 1. Register foundational services (no dependencies)\n    container.register<IOptionManager>(\n        \"optionManager\",\n        () => new OptionManager(options),\n        { dependencies: [] }\n    );\n\n    container.register<IHttpClient>(\n        \"httpClient\",\n        () => new HttpClient(),\n        { dependencies: [] }\n    );\n\n    // 2. Register logger factory (depends on optionManager)\n    container.register<ILoggerFactory>(\n        \"loggerFactory\",\n        (c) => new LoggerFactory(instanceId, c.resolve<IOptionManager>(\"optionManager\")),\n        { dependencies: [\"optionManager\"] }\n    );\n\n    // 3. Register component loggers\n    container.register<ILogger>(\n        \"authLogger\",\n        (c) => c.resolve<ILoggerFactory>(\"loggerFactory\").createLogger(\"AuthManager\"),\n        { dependencies: [\"loggerFactory\"] }\n    );\n\n    container.register<ILogger>(\n        \"connectionLogger\",\n        (c) => c.resolve<ILoggerFactory>(\"loggerFactory\").createLogger(\"Connection\"),\n        { dependencies: [\"loggerFactory\"] }\n    );\n\n    container.register<ILogger>(\n        \"wsClientLogger\",\n        (c) => c.resolve<ILoggerFactory>(\"loggerFactory\").createLogger(\"WebSocketClient\"),\n        { dependencies: [\"loggerFactory\"] }\n    );\n\n    container.register<ILogger>(\n        \"socketChannelLogger\",\n        (c) => c.resolve<ILoggerFactory>(\"loggerFactory\").createLogger(\"SocketChannelManager\"),\n        { dependencies: [\"loggerFactory\"] }\n    );\n\n    // 4. Register managers with dependencies\n    container.register<IAuthManager>(\n        \"authManager\",\n        (c) => new AuthManager(\n            c.resolve<IOptionManager>(\"optionManager\"),\n            c.resolve<IHttpClient>(\"httpClient\"),\n            c.resolve<ILogger>(\"authLogger\")\n        ),\n        { dependencies: [\"optionManager\", \"httpClient\", \"authLogger\"] }\n    );\n\n    container.register<IWebSocketClient>(\n        \"wsClient\",\n        (c) => new WebSocketClient(c.resolve<ILogger>(\"wsClientLogger\")),\n        { dependencies: [\"wsClientLogger\"] }\n    );\n\n    container.register<ISocketChannelManager>(\n        \"socketChannelManager\",\n        (c) => new SocketChannelManager(\n            c.resolve<IWebSocketClient>(\"wsClient\"),\n            c.resolve<ILogger>(\"socketChannelLogger\")\n        ),\n        { dependencies: [\"wsClient\", \"socketChannelLogger\"] }\n    );\n\n    // 5. Register connection (depends on multiple services)\n    container.register<IConnection>(\n        \"connection\",\n        (c) => new Connection(\n            c.resolve<IOptionManager>(\"optionManager\"),\n            c.resolve<IAuthManager>(\"authManager\"),\n            c.resolve<IWebSocketClient>(\"wsClient\"),\n            c.resolve<ISocketChannelManager>(\"socketChannelManager\"),\n            c.resolve<ILogger>(\"connectionLogger\")\n        ),\n        { \n            dependencies: [\n                \"optionManager\", \n                \"authManager\", \n                \"wsClient\", \n                \"socketChannelManager\", \n                \"connectionLogger\"\n            ] \n        }\n    );\n}\n\n/**\n * Register all services for REST-based instances\n */\nexport function registerRestServices(\n    container: ServiceContainer,\n    instanceId: string,\n    options: Partial<Option> = {}\n): void {\n    // 1. Register foundational services (no dependencies)\n    container.register<IOptionManager>(\n        \"optionManager\",\n        () => new OptionManager(options),\n        { dependencies: [] }\n    );\n\n    container.register<IHttpClient>(\n        \"httpClient\",\n        () => new HttpClient(),\n        { dependencies: [] }\n    );\n\n    // 2. Register logger factory (depends on optionManager)\n    container.register<ILoggerFactory>(\n        \"loggerFactory\",\n        (c) => new LoggerFactory(instanceId, c.resolve<IOptionManager>(\"optionManager\")),\n        { dependencies: [\"optionManager\"] }\n    );\n\n    // 3. Register component loggers\n    container.register<ILogger>(\n        \"authLogger\",\n        (c) => c.resolve<ILoggerFactory>(\"loggerFactory\").createLogger(\"AuthManager\"),\n        { dependencies: [\"loggerFactory\"] }\n    );\n\n    container.register<ILogger>(\n        \"restChannelLogger\",\n        (c) => c.resolve<ILoggerFactory>(\"loggerFactory\").createLogger(\"RestChannelManager\"),\n        { dependencies: [\"loggerFactory\"] }\n    );\n\n    // 4. Register managers with dependencies\n    container.register<IAuthManager>(\n        \"authManager\",\n        (c) => new AuthManager(\n            c.resolve<IOptionManager>(\"optionManager\"),\n            c.resolve<IHttpClient>(\"httpClient\"),\n            c.resolve<ILogger>(\"authLogger\")\n        ),\n        { dependencies: [\"optionManager\", \"httpClient\", \"authLogger\"] }\n    );\n\n    container.register<RestChannelManager>(\n        \"restChannelManager\",\n        (c) => new RestChannelManager(\n            c.resolve<IHttpClient>(\"httpClient\"),\n            c.resolve<IAuthManager>(\"authManager\"),\n            c.resolve<IOptionManager>(\"optionManager\"),\n            c.resolve<ILogger>(\"restChannelLogger\")\n        ),\n        { dependencies: [\"httpClient\", \"authManager\", \"optionManager\", \"restChannelLogger\"] }\n    );\n}\n\n/**\n * Bootstrap a container with validation\n */\nexport function bootstrapContainer(\n    container: ServiceContainer,\n    type: \"socket\" | \"rest\",\n    instanceId: string,\n    options: Partial<Option> = {}\n): void {\n    // Register services based on type\n    if (type === \"socket\") {\n        registerSocketServices(container, instanceId, options);\n    } else {\n        registerRestServices(container, instanceId, options);\n    }\n\n    // Validate all service dependencies\n    try {\n        container.validate();\n    } catch (error) {\n        throw new Error(\n            `Service container validation failed for ${type} instance '${instanceId}': ${\n                error instanceof Error ? error.message : String(error)\n            }`\n        );\n    }\n} ","/**\n * Generate a UUID v7 for client-side instance identification.\n * This implementation is designed for generating unique identifiers within a single runtime instance\n * (browser session or Node.js process), specifically for Socket and Rest class instances.\n * It combines timestamp and random values to ensure uniqueness within the same runtime.\n *\n * This implementation is platform-agnostic and works in both browser and Node.js environments\n * as it only uses standard JavaScript APIs (Date.now() and Math.random()).\n *\n * Note: This is NOT a cryptographically secure implementation and should not be used\n * for security-sensitive purposes or when cross-instance uniqueness is required.\n *\n * @returns UUID v7 string formatted as: timestamp-timestamp-variant-random-random\n */\nexport function uuidv7(): string {\n    const timestamp = BigInt(Date.now());\n    const timestampHex = timestamp.toString(16).padStart(12, \"0\");\n\n    // Generate 20 random hex characters (10 bytes)\n    const randomHex = Array.from({ length: 20 }, () =>\n        Math.floor(Math.random() * 16).toString(16)\n    ).join(\"\");\n\n    return `${timestampHex.slice(0, 8)}-${timestampHex.slice(\n        8,\n        12\n    )}-7${randomHex.slice(0, 3)}-${(\n        8 +\n        (parseInt(randomHex[0], 16) & 0x3)\n    ).toString(16)}${randomHex.slice(3, 6)}-${randomHex.slice(6, 16)}`;\n}\n","import { Option } from \"../types/config/options\";\nimport { ServiceContainer, bootstrapContainer } from \"./bootstrap\";\nimport { uuidv7 } from \"./shared\";\nimport { RestChannelManager } from \"./managers/channel-manager\";\nimport {\n    IOptionManager,\n} from \"../types/services/managers\";\nimport {\n    ILogger,\n    ILoggerFactory,\n} from \"../types/services/clients\";\n\nexport class Rest {\n    private instanceId: string;\n    private container: ServiceContainer;\n    \n    // Public API - expose through interfaces for clean contracts\n    public readonly optionManager: IOptionManager;\n    public readonly channels: RestChannelManager;\n    \n    private logger: ILogger;\n\n    constructor(options?: Partial<Option>) {\n        this.instanceId = `rest_${uuidv7()}`;\n        \n        // Initialize service container\n        this.container = new ServiceContainer(this.instanceId);\n        \n        // Bootstrap all services\n        bootstrapContainer(this.container, \"rest\", this.instanceId, options);\n        \n        // Resolve main services\n        this.optionManager = this.container.resolve<IOptionManager>(\"optionManager\");\n        this.channels = this.container.resolve<RestChannelManager>(\"restChannelManager\");\n        \n        // Get logger for this component\n        const loggerFactory = this.container.resolve<ILoggerFactory>(\"loggerFactory\");\n        this.logger = loggerFactory.createLogger(\"REST\");\n\n        this.logger.info(\"Rest instance created\");\n    }\n\n    public reset(): void {\n        this.logger.info(\"Resetting REST instance\");\n        \n        // Reset all services in reverse dependency order\n        this.channels.reset();\n        this.optionManager.reset();\n        \n        // Clear container instances to ensure fresh state\n        this.container.clearInstances();\n    }\n\n    // Getter for instance ID\n    public getInstanceId(): string {\n        return this.instanceId;\n    }\n}\n","import { Option } from \"../types/config/options\";\nimport { ServiceContainer, bootstrapContainer } from \"./bootstrap\";\nimport { uuidv7 } from \"./shared\";\nimport {\n    IOptionManager,\n    IAuthManager,\n    ISocketChannelManager,\n} from \"../types/services/managers\";\nimport {\n    ILogger,\n    ILoggerFactory,\n} from \"../types/services/clients\";\nimport { IConnection } from \"../types/services/connection\";\n\nexport class Socket {\n    private instanceId: string;\n    private container: ServiceContainer;\n    private abortController: AbortController; // Add abort controller for cancellation\n    \n    // Public API - expose through interfaces for clean contracts\n    public readonly optionManager: IOptionManager;\n    public readonly authManager: IAuthManager;\n    public readonly connection: IConnection;\n    public readonly channels: ISocketChannelManager;\n    \n    private logger: ILogger;\n\n    constructor(options?: Partial<Option>) {\n        this.instanceId = `socket_${uuidv7()}`;\n        this.abortController = new AbortController(); // Initialize abort controller\n        \n        // Initialize service container\n        this.container = new ServiceContainer(this.instanceId);\n        \n        // Bootstrap all services\n        bootstrapContainer(this.container, \"socket\", this.instanceId, options);\n        \n        // Resolve main services\n        this.optionManager = this.container.resolve<IOptionManager>(\"optionManager\");\n        this.authManager = this.container.resolve<IAuthManager>(\"authManager\");\n        this.connection = this.container.resolve<IConnection>(\"connection\");\n        this.channels = this.container.resolve<ISocketChannelManager>(\"socketChannelManager\");\n        \n        // Get logger for this component\n        const loggerFactory = this.container.resolve<ILoggerFactory>(\"loggerFactory\");\n        this.logger = loggerFactory.createLogger(\"Socket\");\n\n        if (this.optionManager.getOption(\"autoConnect\")) {\n            this.logger.info(\"Auto-connecting socket\");\n            this.connection.connect();\n        }\n\n        this.logger.info(\"Socket instance created\");\n    }\n\n    public reset(): void {\n        this.logger.info(\"Resetting Socket instance\");\n        \n        // 1. Signal cancellation to all pending operations\n        this.abortController.abort();\n        \n        // 2. Create new abort controller for future operations\n        this.abortController = new AbortController();\n        \n        // 3. Reset services in proper order - stop operations before clearing options\n        this.connection.reset();\n        this.channels.reset(); \n        this.authManager.reset();\n        \n        // 4. Only reset options after all operations are stopped\n        this.optionManager.reset();\n        \n        // 5. Clear container instances to ensure fresh state\n        this.container.clearInstances();\n        \n        this.logger.info(\"Socket instance reset completed\");\n    }\n\n    // Getter for abort signal to pass to services\n    public getAbortSignal(): AbortSignal {\n        return this.abortController.signal;\n    }\n\n    // Getter for instance ID\n    public getInstanceId(): string {\n        return this.instanceId;\n    }\n}\n","import { ServiceContainer, registerSocketServices, registerRestServices } from \"../core/bootstrap\";\nimport { Option } from \"../types/config/options\";\nimport {\n    IOptionManager,\n    IAuthManager,\n    ISocketChannelManager,\n} from \"../types/services/managers\";\nimport {\n    IWebSocketClient,\n    IHttpClient,\n    ILogger,\n    ILoggerFactory,\n} from \"../types/services/clients\";\nimport { IConnection } from \"../types/services/connection\";\n\n/**\n * Test-specific service container with enhanced mocking capabilities\n */\nexport class TestContainer extends ServiceContainer {\n    /**\n     * Register a mock implementation for a service\n     * \n     * @param key - Service identifier\n     * @param mockInstance - Mock instance to use\n     */\n    mock<T>(key: string, mockInstance: T): void {\n        // Clear any existing instance\n        this.clearService(key);\n        \n        // Register the mock as a singleton\n        this.register<T>(\n            key,\n            () => mockInstance,\n            { lifetime: \"singleton\" }\n        );\n    }\n\n    /**\n     * Override a service registration with a new factory\n     * \n     * @param key - Service identifier\n     * @param factory - New factory function\n     */\n    override<T>(key: string, factory: (container: ServiceContainer) => T): void {\n        // Clear any existing instance\n        this.clearService(key);\n        \n        // Register the override\n        this.register<T>(key, factory, { lifetime: \"singleton\" });\n    }\n\n    /**\n     * Clear a specific service instance and registration\n     * \n     * @param key - Service identifier\n     */\n    private clearService(key: string): void {\n        // Access private members for testing purposes\n        (this as any).instances.delete(key);\n        (this as any).definitions.delete(key);\n    }\n}\n\n/**\n * Create a test container with Socket services pre-registered\n * \n * @param instanceId - Test instance identifier\n * @param options - Socket options\n * @returns Configured test container\n */\nexport function createTestSocketContainer(\n    instanceId: string = \"test-socket\",\n    options: Partial<Option> = {}\n): TestContainer {\n    const container = new TestContainer(instanceId);\n    registerSocketServices(container, instanceId, options);\n    return container;\n}\n\n/**\n * Create a test container with REST services pre-registered\n * \n * @param instanceId - Test instance identifier  \n * @param options - REST options\n * @returns Configured test container\n */\nexport function createTestRestContainer(\n    instanceId: string = \"test-rest\",\n    options: Partial<Option> = {}\n): TestContainer {\n    const container = new TestContainer(instanceId);\n    registerRestServices(container, instanceId, options);\n    return container;\n}\n\n/**\n * Mock function interface for type safety\n */\ninterface MockFunction<T extends (...args: any[]) => any> {\n    (...args: Parameters<T>): ReturnType<T>;\n    mockReturnValue(value: ReturnType<T>): MockFunction<T>;\n    mockResolvedValue: T extends (...args: any[]) => Promise<infer R> \n        ? (value: R) => MockFunction<T> \n        : never;\n    mockRejectedValue: T extends (...args: any[]) => Promise<any>\n        ? (error: any) => MockFunction<T>\n        : never;\n    mockImplementation(fn: T): MockFunction<T>;\n    mockClear(): void;\n    mockReset(): void;\n}\n\n/**\n * Mocked type for service interfaces\n */\ntype Mocked<T> = {\n    [K in keyof T]: T[K] extends (...args: any[]) => any \n        ? MockFunction<T[K]> \n        : T[K];\n};\n\n/**\n * Create a mock function with Jest compatibility\n */\nfunction createMockFn<T extends (...args: any[]) => any>(\n    defaultReturnValue?: ReturnType<T>\n): MockFunction<T> {\n    // Check if Jest is available using global access\n    const globalObj = (typeof global !== 'undefined' ? global : window) as any;\n    const isJestAvailable = globalObj.jest && typeof globalObj.jest.fn === 'function';\n    \n    if (isJestAvailable) {\n        const jestMock = globalObj.jest.fn() as any;\n        if (defaultReturnValue !== undefined) {\n            jestMock.mockReturnValue(defaultReturnValue);\n        }\n        return jestMock;\n    }\n    \n    // Fallback implementation for non-Jest environments\n    const mockFn = ((...args: any[]) => defaultReturnValue) as any;\n    mockFn.mockReturnValue = (value: ReturnType<T>) => {\n        mockFn._returnValue = value;\n        return mockFn;\n    };\n    mockFn.mockResolvedValue = (value: any) => {\n        mockFn._returnValue = Promise.resolve(value);\n        return mockFn;\n    };\n    mockFn.mockRejectedValue = (error: any) => {\n        mockFn._returnValue = Promise.reject(error);\n        return mockFn;\n    };\n    mockFn.mockImplementation = (fn: T) => {\n        Object.setPrototypeOf(mockFn, fn);\n        return mockFn;\n    };\n    mockFn.mockClear = () => {/* no-op */};\n    mockFn.mockReset = () => {/* no-op */};\n    \n    return mockFn;\n}\n\n/**\n * Mock factory functions for creating service mocks\n */\nexport const MockFactory = {\n    /**\n     * Create a mock IOptionManager\n     */\n    createOptionManager(overrides: Partial<IOptionManager> = {}): Mocked<IOptionManager> {\n        return {\n            getOption: createMockFn(),\n            setOption: createMockFn(),\n            reset: createMockFn(),\n            ...overrides,\n        } as Mocked<IOptionManager>;\n    },\n\n    /**\n     * Create a mock IAuthManager\n     */\n    createAuthManager(overrides: Partial<IAuthManager> = {}): Mocked<IAuthManager> {\n        return {\n            authenticate: createMockFn(),\n            isAuthenticated: createMockFn(false),\n            shouldAutoAuthenticate: createMockFn(false),\n            getAuthenticateUrl: createMockFn(\"\"),\n            requestToken: createMockFn(),\n            getCurrentToken: createMockFn(null),\n            getToken: createMockFn(null),\n            clearToken: createMockFn(),\n            getAuthHeaders: createMockFn({}),\n            getAuthQueryParams: createMockFn(\"\"),\n            reset: createMockFn(),\n            on: createMockFn(),\n            off: createMockFn(),\n            emit: createMockFn(),\n            removeAllListeners: createMockFn(),\n            ...overrides,\n        } as Mocked<IAuthManager>;\n    },\n\n    /**\n     * Create a mock IWebSocketClient\n     */\n    createWebSocketClient(overrides: Partial<IWebSocketClient> = {}): Mocked<IWebSocketClient> {\n        return {\n            connect: createMockFn(),\n            disconnect: createMockFn(),\n            isConnected: createMockFn(false),\n            getSocket: createMockFn(null),\n            send: createMockFn(),\n            reset: createMockFn(),\n            ...overrides,\n        } as Mocked<IWebSocketClient>;\n    },\n\n    /**\n     * Create a mock IConnection\n     */\n    createConnection(overrides: Partial<IConnection> = {}): Mocked<IConnection> {\n        return {\n            connect: createMockFn(),\n            disconnect: createMockFn(),\n            isConnected: createMockFn(false),\n            reset: createMockFn(),\n            on: createMockFn(),\n            off: createMockFn(),\n            emit: createMockFn(),\n            removeAllListeners: createMockFn(),\n            ...overrides,\n        } as Mocked<IConnection>;\n    },\n\n    /**\n     * Create a mock ISocketChannelManager\n     */\n    createSocketChannelManager(overrides: Partial<ISocketChannelManager> = {}): Mocked<ISocketChannelManager> {\n        return {\n            get: createMockFn(),\n            has: createMockFn(false),\n            remove: createMockFn(),\n            reset: createMockFn(),\n            resubscribeAllChannels: createMockFn(),\n            pendingSubscribeAllChannels: createMockFn(),\n            ...overrides,\n        } as Mocked<ISocketChannelManager>;\n    },\n\n    /**\n     * Create a mock IHttpClient\n     */\n    createHttpClient(overrides: Partial<IHttpClient> = {}): Mocked<IHttpClient> {\n        return {\n            get: createMockFn(),\n            post: createMockFn(),\n            put: createMockFn(),\n            delete: createMockFn(),\n            patch: createMockFn(),\n            ...overrides,\n        } as Mocked<IHttpClient>;\n    },\n\n    /**\n     * Create a mock ILogger\n     */\n    createLogger(overrides: Partial<ILogger> = {}): Mocked<ILogger> {\n        return {\n            error: createMockFn(),\n            warn: createMockFn(),\n            info: createMockFn(),\n            debug: createMockFn(),\n            trace: createMockFn(),\n            ...overrides,\n        } as Mocked<ILogger>;\n    },\n\n    /**\n     * Create a mock ILoggerFactory\n     */\n    createLoggerFactory(overrides: Partial<ILoggerFactory> = {}): Mocked<ILoggerFactory> {\n        const mockLogger = MockFactory.createLogger();\n        return {\n            createLogger: createMockFn(mockLogger),\n            ...overrides,\n        } as Mocked<ILoggerFactory>;\n    },\n};\n\n/**\n * Test utilities for common testing scenarios\n */\nexport const TestUtils = {\n    /**\n     * Create a fully mocked Socket container for isolated testing\n     */\n    createMockedSocketContainer(instanceId: string = \"test-socket\"): {\n        container: TestContainer;\n        mocks: {\n            optionManager: Mocked<IOptionManager>;\n            authManager: Mocked<IAuthManager>;\n            wsClient: Mocked<IWebSocketClient>;\n            connection: Mocked<IConnection>;\n            socketChannelManager: Mocked<ISocketChannelManager>;\n            logger: Mocked<ILogger>;\n            loggerFactory: Mocked<ILoggerFactory>;\n        };\n    } {\n        const container = new TestContainer(instanceId);\n        \n        const mocks = {\n            optionManager: MockFactory.createOptionManager(),\n            authManager: MockFactory.createAuthManager(),\n            wsClient: MockFactory.createWebSocketClient(),\n            connection: MockFactory.createConnection(),\n            socketChannelManager: MockFactory.createSocketChannelManager(),\n            logger: MockFactory.createLogger(),\n            loggerFactory: MockFactory.createLoggerFactory(),\n        };\n\n        // Register all mocks\n        container.mock(\"optionManager\", mocks.optionManager);\n        container.mock(\"authManager\", mocks.authManager);\n        container.mock(\"wsClient\", mocks.wsClient);\n        container.mock(\"connection\", mocks.connection);\n        container.mock(\"socketChannelManager\", mocks.socketChannelManager);\n        container.mock(\"loggerFactory\", mocks.loggerFactory);\n\n        return { container, mocks };\n    },\n\n    /**\n     * Create a partially mocked container with some real services\n     * \n     * @param realServices - Services to keep as real implementations\n     * @param options - Options for real services\n     */\n    createPartiallyMockedContainer(\n        realServices: string[] = [\"optionManager\"],\n        options: Partial<Option> = {}\n    ): TestContainer {\n        const container = createTestSocketContainer(\"test-partial\", options);\n        \n        // Mock all services except the ones specified as real\n        const allServices = [\n            \"authManager\",\n            \"wsClient\", \n            \"connection\",\n            \"socketChannelManager\",\n            \"loggerFactory\",\n        ];\n        \n        allServices\n            .filter(service => !realServices.includes(service))\n            .forEach(service => {\n                switch (service) {\n                    case \"authManager\":\n                        container.mock(service, MockFactory.createAuthManager());\n                        break;\n                    case \"wsClient\":\n                        container.mock(service, MockFactory.createWebSocketClient());\n                        break;\n                    case \"connection\":\n                        container.mock(service, MockFactory.createConnection());\n                        break;\n                    case \"socketChannelManager\":\n                        container.mock(service, MockFactory.createSocketChannelManager());\n                        break;\n                    case \"loggerFactory\":\n                        container.mock(service, MockFactory.createLoggerFactory());\n                        break;\n                }\n            });\n        \n        return container;\n    },\n}; ","import { Rest } from \"./core/rest\";\nimport { Socket } from \"./core/socket\";\n\n// Re-export core types for convenience\nexport type { Message } from \"./types/protocol/messages\";\nexport type { Option } from \"./types/config/options\";\nexport type { TokenOptions, TokenRequest, AuthResponse } from \"./types/config/auth\";\n\n// Re-export service interfaces for advanced usage and testing\nexport type {\n    IOptionManager,\n    IAuthManager,\n    IChannelManager,\n    ISocketChannelManager,\n} from \"./types/services/managers\";\nexport type {\n    IWebSocketClient,\n    IHttpClient,\n    ILogger,\n    ILoggerFactory,\n} from \"./types/services/clients\";\nexport type { IConnection } from \"./types/services/connection\";\n\n// Re-export dependency injection utilities for advanced usage\nexport {\n    ServiceContainer,\n    type ServiceLifetime,\n    type ServiceRegistrationOptions,\n    registerSocketServices,\n    registerRestServices,\n    bootstrapContainer,\n} from \"./core/bootstrap\";\n\n// Re-export testing utilities for unit testing\nexport {\n    TestContainer,\n    createTestSocketContainer,\n    createTestRestContainer,\n    MockFactory,\n    TestUtils,\n} from \"./testing\";\n\n// Re-export event constants and types for consumer use\nexport { \n    ConnectionEvents, \n    ChannelEvents, \n    AuthEvents \n} from \"./types/events/constants\";\n\nexport type { \n    ConnectionEvent,\n    ChannelEvent, \n    AuthEvent,\n} from \"./types/events/constants\";\n\nexport type {\n    ConnectionEventPayloads,\n    ChannelEventPayloads,\n    AuthEventPayloads,\n} from \"./types/events/payloads\";\n\nexport type {\n    EventListener,\n    ConnectionEventListener,\n    ChannelEventListener, \n    AuthEventListener,\n    ConnectionEventListeners,\n    ChannelEventListeners,\n    AuthEventListeners\n} from \"./types/events/listeners\";\n\nexport const QPub = {\n    Rest: Rest,\n    Socket: Socket,\n} as const;\n\nexport { Rest, Socket };\n"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","__extends","TypeError","String","__","this","constructor","create","__assign","assign","t","s","i","n","arguments","length","apply","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","__generator","body","f","y","_","label","sent","trys","ops","g","Iterator","verb","Symbol","iterator","v","op","pop","push","__spreadArray","to","from","pack","ar","l","slice","concat","SuppressedError","ActionType","ServiceContainer","instanceId","definitions","Map","instances","resolutionStack","register","key","factory","options","has","Error","set","lifetime","_a","dependencies","_b","includes","cycle","join","get","definition","keys","instance","error","message","isRegistered","isInstantiated","getRegisteredServices","getInstanceId","validate","_this","allServices","Set","entries","forEach","serviceKey","_i","dependency","validateCircularDependencies","visited","visiting","visit","path","add","delete","clearInstances","clear","reset","DEFAULT_OPTIONS","httpHost","httpPort","wsHost","wsPort","isSecure","autoConnect","autoReconnect","autoResubscribe","autoAuthenticate","connectTimeoutMs","maxReconnectAttempts","initialReconnectDelayMs","maxReconnectDelayMs","reconnectBackoffMultiplier","resubscribeIntervalMs","authenticateRetries","authenticateRetryIntervalMs","pingTimeoutMs","debug","logLevel","OptionManager","getOption","optionName","setOption","newOption","HttpClient","defaultHeaders","customFetch","fetchImpl","getDefaultFetch","fetch","bind","globalThis","createNodeFetch","http","require","https","URL","input","init","parsed","toString","protocol","method","headers","hostname","pathname","search","port","req","request","res","chunks","on","chunk","Buffer","response","ok","statusCode","status","statusText","statusMessage","json","JSON","parse","text","write","end","url","url_1","post","data_1","data","stringify","put","patch","Logger","component","optionManager","shouldLog","level","LOG_LEVEL_MAP","formatMessage","args","timestamp","Date","toISOString","split","shortId","formattedMessage","toUpperCase","log","customLogger","console","warn","info","trace","LOG_LEVELS","EventEmitter","events","event","listener","off","listeners","size","once","onceWrapper","emit","removeAllListeners","listenerCount","eventNames","Crypto","getSubtleCrypto","window","crypto","subtle","global","crypto_1","webcrypto","hmacSign","encoder","TextEncoder","keyBytes","encode","dataBytes","importKey","name","hash","cryptoKey","sign","signature","arrayBufferToBase64","error_1","buffer","binary","Uint8Array","reduce","str","byte","fromCharCode","btoa","JWT","decode","token","headerB64","payloadB64","header","atob","payload","kid","alias","exp","isExpired","now","apiKeyId","privateKey","alg","typ","encodedHeader","base64UrlEncode","encodedPayload","dataToSign","encodedSignature","base64Decode","replace","ApiKey","apiKey","ConnectionEvents","INITIALIZED","CONNECTING","OPENED","CONNECTED","DISCONNECTED","CLOSING","CLOSED","FAILED","ChannelEvents","SUBSCRIBING","SUBSCRIBED","UNSUBSCRIBING","UNSUBSCRIBED","PAUSED","RESUMED","AuthEvents","TOKEN_UPDATED","TOKEN_EXPIRED","TOKEN_ERROR","AUTH_ERROR","AuthManager","_super","httpClient","logger","currentToken","_isResetting","abortController","AbortController","tokenRequest","requestToken","catch","handleError","context","formattedError","authenticate","retries","retryInterval","attempt","signal","aborted","_authenticate","isLastAttempt","setTimeout","authUrl","authOptions","hasAuthUrl","hasApiKey","hasAuthOptions","setToken","shouldAutoAuthenticate","autoAuth","decoded","expiresAt","undefined","scheduleTokenRefresh","getToken","expiredAt","clearToken","refreshTimeout","clearTimeout","delay","refreshDate","Math","round","getAuthHeaders","Authorization","getAuthQueryParams","encodeURIComponent","params","getAuthenticateUrl","baseUrl","authQueryParams","separator","substring","generateToken","expiresIn","floor","permissions","error_2","issueToken","host","error_3","createTokenRequest","error_4","hasAlias","hasPermissions","error_5","isAuthenticated","authenticated","getCurrentToken","abort","getAbortSignal","WebSocketClient","socket","WebSocket","WebSocketImplementation","getSocket","connect","disconnect","onerror","isConnected","readyState","OPEN","close","send","CONNECT","DISCONNECT","SUBSCRIBE","UNSUBSCRIBE","PUBLISH","PUBLISHED","MESSAGE","ERROR","PING","PONG","BaseChannel","channelName","getName","SocketChannel","wsClient","subscribed","pendingSubscribe","pendingUnsubscribe","operationQueue","paused","pausedMessages","bufferWhilePaused","eventCallbacks","pendingTimeouts","messageHandler","channel","handleMessage","action","setupMessageHandler","removeEventListener","addEventListener","processOperationQueue","operation","shift","type","executeSubscribe","callback","executeUnsubscribe","transformToConsumerMessages","incomingMessage","id","messages","map","messagePayload","index","isSubscribed","incomingDataMessage","consumerMessages","consumerMessage","messageCallback","subscription_id","subscriptionId","publish","publishMessage","subscribe","timeout","needsNetworkConfirmation","willQueue","handleSubscribed","cleanup","handleFailed","timeoutId","callbacks","cb","actionMessage_1","actionMessage","resubscribe","existingCallback","existingEventCallbacks","unsubscribe","willBeEmpty","isLastEvent","handleUnsubscribed","isPendingSubscribe","setPendingSubscribe","pending","pause","bufferMessages","buffering","resume","bufferedCount","bufferedMessagesDelivered","isPaused","hasCallback","clearBufferedMessages","count","RestChannel","authManager","requestPayload","SocketChannelManager","channels","channelRefCounts","isNewChannel","currentCount","release","getAllChannels","values","remove","pendingSubscribeAllChannels","channels_1","resubscribeAllChannels","allChannels","channelsToResubscribe","filter","channelsToResubscribe_1","RestChannelManager","publishBatch","Connection","channelManager","reconnectAttempts","isReconnecting","isIntentionalDisconnect","pendingPings","pingCounter","setupAuthListeners","getAuthenticatedWsUrl","secure","wsUrl","setupSocketListeners","handleAuthError","isResetting","ping","pingId","startTime","performance","pingMessage","onopen","setupPingHandler","onclose","code","reason","pingTimeout","wasClean","handleConnectionClosed","onmessage","connMessage","connectionId","connection_id","connectionDetails","connection_details","handlePongResponse","handleTokenExpired","PING_TIMEOUT","onping","handleConnectionInterrupted","onpong","pendingPing","rtt","toFixed","attemptReconnection","calculateReconnectDelay","initial","max","multiplier","pow","min","maxAttempts","delay_1","this_1","connectionPromise","isHandled","reconnectTimeout","stopAllPendingOperations","cleanupTimers","resetState","LoggerFactory","createLogger","registerSocketServices","container","c","registerRestServices","bootstrapContainer","uuidv7","timestampHex","BigInt","padStart","randomHex","random","parseInt","Rest","loggerFactory","Socket","connection","TestContainer","mock","mockInstance","clearService","override","createTestSocketContainer","createTestRestContainer","createMockFn","defaultReturnValue","globalObj","jest","fn","jestMock","mockReturnValue","mockFn","_returnValue","mockResolvedValue","mockRejectedValue","mockImplementation","mockClear","mockReset","MockFactory","createOptionManager","overrides","createAuthManager","createWebSocketClient","createConnection","createSocketChannelManager","createHttpClient","createLoggerFactory","mockLogger","TestUtils","createMockedSocketContainer","mocks","socketChannelManager","createPartiallyMockedContainer","realServices","service","QPub"],"mappings":"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"}